{"./":{"url":"./","title":"前言","keywords":"","body":"简介简介 ​ 该books站点为古道长亭的技术系列,喜欢的朋友可以收藏该站点或者博客站点,也可以关注博主的GitHub,以及CSDN,互相交流学习. ​ Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2019-11-07 23:31:37 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/":{"url":"Chapter1/","title":"JAVA技术","keywords":"","body":"JAVA技术JAVA技术 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2019-11-07 23:31:37 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/string/String.html":{"url":"Chapter1/string/String.html","title":"String","keywords":"","body":"String实例化方式常用方法StringBuffer常用方法StringBuilder常用方法常见算法String 字符串,是一个final类,不可变字符序列,字符内容存储在一个字符数组value[]中 不可变性 char[]存储 实例化方式 字面量 构造器new 常用方法 ...略过 StringBuffer 可变 线程安全,效率低 char[]存储 默认capacity为16,不够时会继续扩容,默认扩容为capacity 常用方法 ...略过 StringBuilder 可变 线程不安全,效率高 jdk5.0新增 char[]存储 常用方法 ...略过 建议: 使用 StringBuffer(int capacity) 或 StringBuilder(int capacity) 常见算法 将一个字符串进行反转。将字符串中指定部分进行反转。比如“abcdefg”反转为”abfedcg” public class StringDemo { //方式一：转换为char[] public String reverse(String str, int startIndex, int endIndex) { if (str != null) { char[] arr = str.toCharArray(); for (int x = startIndex, y = endIndex; x = startIndex; i--) { reverseStr += str.charAt(i); } //第3部分 reverseStr += str.substring(endIndex + 1); return reverseStr; } return null; } //方式三：使用StringBuffer/StringBuilder替换String public String reverse2(String str, int startIndex, int endIndex) { if (str != null) { StringBuilder builder = new StringBuilder(str.length()); //第1部分 builder.append(str.substring(0, startIndex)); //第2部分 for (int i = endIndex; i >= startIndex; i--) { builder.append(str.charAt(i)); } //第3部分 builder.append(str.substring(endIndex + 1)); return builder.toString(); } return null; } @Test public void testReverse() { String str = \"abcdefg\"; String reverse = reverse1(str, 2, 5); System.out.println(reverse); } } 获取一个字符串在另一个字符串中出现的次数。比如：获取“ab”在 “abkkcadkabkebfkaabkskab” 中出现的次数 public class StringDemo { /** * 获取subStr在mainStr中出现的次数 */ public int getCount(String mainStr, String subStr) { int mainLength = mainStr.length(); int subLength = subStr.length(); int count = 0; int index = 0; if (mainLength >= subLength) { //方式一： // while((index = mainStr.indexOf(subStr)) != -1){ // count++; // mainStr = mainStr.substring(index + subStr.length()); // } //方式二：对方式一的改进 while ((index = mainStr.indexOf(subStr, index)) != -1) { count++; index += subLength; } return count; } else { return 0; } } @Test public void testGetCount() { String mainStr = \"abkkcadkabkebfkaabkskab\"; String subStr = \"ab\"; int count = getCount(mainStr, subStr); System.out.println(count); } } 获取两个字符串中最大相同子串。比如：str1 = \"abcwerthelloyuiodefabcdef\";str2 = \"cvhellobnm\" 提示：将短的那个串进行长度依次递减的子串与较长的串比较。 public class StringDemo2 { //前提：两个字符串中只有一个最大相同子串 public String getMaxSameString(String str1, String str2) { if (str1 != null && str2 != null) { String maxStr = (str1.length() >= str2.length()) ? str1 : str2; String minStr = (str1.length() str2.length()) ? str1 : str2; String minString = (str1.length() > str2.length()) ? str2 : str1; int len = minString.length(); for (int i = 0; i Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-08 15:00:18 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/java_version/VERSION.html":{"url":"Chapter1/java_version/VERSION.html","title":"Java各版本特性","keywords":"","body":"jdk版本特性jdk版本特性 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-06 15:33:45 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/java_version/java8.html":{"url":"Chapter1/java_version/java8.html","title":"java8","keywords":"","body":"jdk8jdk8 速度更快 HashMap,ConcurrentHashMap特性改变(链表+红黑树等) --详细看HashMap部分 jvm永久区去掉,MetaSpace 元空间,使用物理内存 代码更少（增加了新的语法 Lambda 表达式） 强大的 Stream API 并行 最大化减少空指针异常 Optional 接口中的默认方法和静态方法 新时间日期 重复注解与类型注解 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-07 13:41:48 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/java_version/java8_lambda.html":{"url":"Chapter1/java_version/java8_lambda.html","title":"Lambda","keywords":"","body":"Lambda表达式原来的写法与lambda表达式对比lambda语法java8内置的四大核心函数式接口Lambda表达式 Lambda 是一个匿名函数，我们可以把 Lambda 表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。 原来的写法与lambda表达式对比 1.匿名内部类 //原来的匿名内部类 @Test public void test1(){ Comparator com = new Comparator(){ @Override public int compare(String o1, String o2) { return Integer.compare(o1.length(), o2.length()); } }; TreeSet ts = new TreeSet<>(com); TreeSet ts2 = new TreeSet<>(new Comparator(){ @Override public int compare(String o1, String o2) { return Integer.compare(o1.length(), o2.length()); } }); } //现在的 Lambda 表达式 @Test public void test2(){ Comparator com = (x, y) -> Integer.compare(x.length(), y.length()); TreeSet ts = new TreeSet<>(com); } 2.集合操作 List emps = Arrays.asList( new Employee(101, \"张三\", 18, 9999.99), new Employee(102, \"李四\", 59, 6666.66), new Employee(103, \"王五\", 28, 3333.33), new Employee(104, \"赵六\", 8, 7777.77), new Employee(105, \"田七\", 38, 5555.55) ); //需求：获取公司中年龄小于 35 的员工信息 public List filterEmployeeAge(List emps){ List list = new ArrayList<>(); for (Employee emp : emps) { if(emp.getAge() list = filterEmployeeAge(emps); for (Employee employee : list) { System.out.println(employee); } } //需求：获取公司中工资大于 5000 的员工信息 public List filterEmployeeSalary(List emps){ List list = new ArrayList<>(); for (Employee emp : emps) { if(emp.getSalary() >= 5000){ list.add(emp); } } return list; } //优化方式二：匿名内部类, 需写接口和实现类,具体看java-learning代码 @Test public void test5(){ List list = filterEmployee(emps, new MyPredicate() { @Override public boolean test(Employee t) { return t.getId() list = filterEmployee(emps, (e) -> e.getAge() list2 = filterEmployee(emps, (e) -> e.getSalary() >= 5000); list2.forEach(System.out::println); } //优化方式四：Stream API @Test public void test7(){ emps.stream() .filter((e) -> e.getAge() lambda语法 Java8中引入了一个新的操作符 \"->\" 该操作符称为箭头操作符或 Lambda 操作符箭头操作符将 Lambda 表达式拆分成两部分, 其中: 左侧:ambda 表达式的参数列表 右侧:Lambda 表达式中所需执行的功能， 即 Lambda 体 语法格式 无参数,无返回值 () -> System.out.println(\"Hello Lambda!\") 有1个参数,无返回值,有1个参数时,小括号可不写 (x) -> System.out.println(x)/ x-> System.out.println(x); 有两个以上的参数，有返回值，并且 Lambda 体中有多条语句 Comparator com = (x, y) -> { System.out.println(\"函数式接口\"); return Integer.compare(x, y); }; 若 Lambda 体中只有一条语句， return 和 大括号都可以省略不写 Comparator com = (x, y) -> Integer.compare(x, y) Lambda 表达式的参数列表的数据类型可以省略不写，因为JVM编译器通过上下文推断出，数据类型，即“类型推断” (Integer x, Integer y) -> Integer.compare(x, y) lambda表达式需要“函数式接口”的支持 函数式接口：接口中只有一个抽象方法的接口，称为函数式接口。 可以使用注解 @FunctionalInterface 修饰,可以检查是否是函数式接口 public class TestLambda2 { @Test public void test1(){ int num = 0;//jdk 1.7 前，必须是 final Runnable r = new Runnable() { @Override public void run() { System.out.println(\"Hello World!\" + num); } }; r.run(); System.out.println(\"-------------------------------\"); Runnable r1 = () -> System.out.println(\"Hello Lambda!\"); r1.run(); } @Test public void test2(){ Consumer con = x -> System.out.println(x); con.accept(\"我和我的祖国！\"); } @Test public void test3(){ Comparator com = (x, y) -> { System.out.println(\"测试多行代码\"); return Integer.compare(x, y); }; } @Test public void test4(){ Comparator com = (x, y) -> Integer.compare(x, y); } //类型抢断示例 @Test public void test5(){ String[] strs = {\"aaa\", \"bbb\", \"ccc\"}; List list = new ArrayList<>(); show(new HashMap<>()); } public void show(Map map){ } //需求：对一个数进行运算 @Test public void test6(){ Integer num = operation(100, (x) -> x * x); System.out.println(num); System.out.println(operation(200, (y) -> y + 200)); } public Integer operation(Integer num, Function function){ return function.apply(num); } } java8内置的四大核心函数式接口 1.Consumer : 消费型接口void accept(T t)2.Supplier : 供给型接口T get()3.Function : 函数型接口R apply(T t)4.Predicate : 断言型接口boolean test(T t) public class TestLambda3 { //Predicate 断言型接口： @Test public void test4(){ List list = Arrays.asList(\"Hello\", \"atguigu\", \"Lambda\", \"www\", \"ok\"); List strList = filterStr(list, (s) -> s.length() > 3); for (String str : strList) { System.out.println(str); } } //需求：将满足条件的字符串，放入集合中 public List filterStr(List list, Predicate pre){ List strList = new ArrayList<>(); for (String str : list) { if(pre.test(str)){ strList.add(str); } } return strList; } //Function 函数型接口： @Test public void test3(){ String newStr = strHandler(\"\\t\\t\\t 我爱我的祖国 \", (str) -> str.trim()); System.out.println(newStr); String subStr = strHandler(\"我爱我的祖国\", (str) -> str.substring(2, 5)); System.out.println(subStr); } //需求：用于处理字符串 public String strHandler(String str, Function fun){ return fun.apply(str); } //Supplier 供给型接口 : @Test public void test2(){ List numList = getNumList(10, () -> (int)(Math.random() * 100)); for (Integer num : numList) { System.out.println(num); } } //需求：产生指定个数的整数，并放入集合中 public List getNumList(int num, Supplier sup){ List list = new ArrayList<>(); for (int i = 0; i 消费型接口 : @Test public void test1(){ happy(10000, (m) -> System.out.println(\"买西瓜花了：\" + m + \"元\")); } public void happy(double money, Consumer con){ con.accept(money); } } 5.其他接口 函数式接口 参数类型 返回类型 用途 BiFunction T,U R 对类型为T,U参数应用操作，返回R类型的结果。包含方法为R apply(T t,U u); UnaryOperator(Function子接口) T T 对类型为T的对象进行一元运算，并返回T类型的结果。包含方法为T apply(T t); BinaryOperator(BiFunction子接口) T,T T 对类型为T的对象进行二元运算，并返回T类型的结果。包含方法为T apply(T t1,T t2); BiConsumer T,U void 对类型为T,U参数应用操作。包含方法为void accept(T t,U u); ToIntFunction ToLongFunction ToDoubleFunction T int,long,double 分别计算int、long、double、值的函数 IntFunction LongFunction DoubleFunction int,long,double R 参数分别为int、long、double类型的函数 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-07 10:18:07 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/java_version/java8_方法与构造器引用.html":{"url":"Chapter1/java_version/java8_方法与构造器引用.html","title":"方法与构造器引用","keywords":"","body":"方法与构造器引用方法与构造器引用 1.方法引用: 若 Lambda 体中的功能，已经有方法提供了实现，可以使用方法引用可以将方法引用理解为 Lambda 表达式的另外一种表现形式） 对象的引用 :: 实例方法名类名 :: 静态方法名类名 :: 实例方法名注意： ①方法引用所引用的方法的参数列表与返回值类型，需要与函数式接口中抽象方法的参数列表和返回值类型保持一致！②若Lambda 的参数列表的第一个参数，是实例方法的调用者，第二个参数(或无参)是实例方法的参数时，格式： ClassName::MethodName //类名 :: 实例方法名 @Test public void test5() { BiPredicate bp = (x, y) -> x.equals(y); System.out.println(bp.test(\"abcde\", \"abcde\")); System.out.println(\"-----------------------------------------\"); BiPredicate bp2 = String::equals; System.out.println(bp2.test(\"abc\", \"abc\")); System.out.println(\"-----------------------------------------\"); Function fun = (e) -> e.show(); System.out.println(fun.apply(new Employee())); System.out.println(\"-----------------------------------------\"); Function fun2 = Employee::show; System.out.println(fun2.apply(new Employee())); } //类名 :: 静态方法名 @Test public void test4() { Comparator com = (x, y) -> Integer.compare(x, y); System.out.println(com.compare(1, 2)); System.out.println(\"-------------------------------------\"); Comparator com2 = Integer::compare; System.out.println(com.compare(2, 2)); } @Test public void test3() { BiFunction fun = (x, y) -> Math.max(x, y); System.out.println(fun.apply(1.5, 22.2)); System.out.println(\"--------------------------------------------------\"); BiFunction fun2 = Math::max; System.out.println(fun2.apply(1.2, 1.5)); } //对象的引用 :: 实例方法名 @Test public void test2() { Employee emp = new Employee(101, \"张三\", 18, 9999.99); Supplier sup = () -> emp.getName(); System.out.println(sup.get()); System.out.println(\"----------------------------------\"); Supplier sup2 = emp::getName; System.out.println(sup2.get()); } @Test public void test1() { PrintStream ps = System.out; Consumer con = (str) -> ps.println(str); con.accept(\"Hello World！\"); System.out.println(\"--------------------------------\"); Consumer con2 = ps::println; con2.accept(\"Hello Java8！\"); Consumer con3 = System.out::println; } 2.构造器引用 :构造器的参数列表，需要与函数式接口中参数列表保持一致 类名::new //构造器引用 @Test public void test7() { Function fun = Employee::new; BiFunction fun2 = Employee::new; } @Test public void test6() { Supplier sup = () -> new Employee(); System.out.println(sup.get()); System.out.println(\"------------------------------------\"); Supplier sup2 = Employee::new; System.out.println(sup2.get()); } 3.数组引用 类型[] :: new //数组引用 @Test public void test8() { Function fun = (args) -> new String[args]; String[] strs = fun.apply(10); System.out.println(strs.length); System.out.println(\"--------------------------\"); Function fun2 = Employee[]::new; Employee[] emps = fun2.apply(20); System.out.println(emps.length); } Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-07 10:21:02 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/java_version/java8_Stream.html":{"url":"Chapter1/java_version/java8_Stream.html","title":"Stream","keywords":"","body":"Stream创建stream中间操作终止操作查找与匹配归约收集Stream 流(Stream) 到底是什么呢？是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。“集合讲的是数据，流讲的是计算！” 注意：Stream 自己不会存储元素Stream 不会改变源对象。相反，他们会返回一个持有结果的新StreamStream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行 创建stream @Test public void test1(){ //1. Collection 提供了两个方法 stream() 与 parallelStream() List list = new ArrayList<>(); Stream stream = list.stream(); //获取一个顺序流 Stream parallelStream = list.parallelStream(); //获取一个并行流 //2. 通过 Arrays 中的 stream() 获取一个数组流 Integer[] nums = new Integer[10]; Stream stream1 = Arrays.stream(nums); //3. 通过 Stream 类中静态方法 of() Stream stream2 = Stream.of(1,2,3,4,5,6); //4. 创建无限流 //迭代 Stream stream3 = Stream.iterate(0, (x) -> x + 2).limit(10); stream3.forEach(System.out::println); //生成 Stream stream4 = Stream.generate(Math::random).limit(2); stream4.forEach(System.out::println); } 中间操作 多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值” 方法 描述 filter(Predicate p) 接收Lambda ，从流中排除某些元素 distinct() 筛选，通过流所生成元素的hashCode() 和equals() 去除重复元素 limit(long maxSize) 截断流，使其元素不超过给定数量 skip(long n) 跳过元素，返回一个扔掉了前n 个元素的流。若流中元素不足n 个，则返回一个空流。与limit(n) 互补 map(Functionf) 接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。 mapToDouble(ToDoubleFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream。 mapToInt(ToIntFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的IntStream。 mapToLong(ToLongFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的LongStream。 flatMap(Function f) 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流 sorted() 产生一个新流，其中按自然顺序排序 sorted(Comparatorcomp) 产生一个新流，其中按比较器顺序排序 public class TestStreamaAPI { //1. 创建 Stream @Test public void test1(){ //1. Collection 提供了两个方法 stream() 与 parallelStream() List list = new ArrayList<>(); Stream stream = list.stream(); //获取一个顺序流 Stream parallelStream = list.parallelStream(); //获取一个并行流 //2. 通过 Arrays 中的 stream() 获取一个数组流 Integer[] nums = new Integer[10]; Stream stream1 = Arrays.stream(nums); //3. 通过 Stream 类中静态方法 of() Stream stream2 = Stream.of(1,2,3,4,5,6); //4. 创建无限流 //迭代 Stream stream3 = Stream.iterate(0, (x) -> x + 2).limit(10); stream3.forEach(System.out::println); //生成 Stream stream4 = Stream.generate(Math::random).limit(2); stream4.forEach(System.out::println); } //2. 中间操作 List emps = Arrays.asList( new Employee(102, \"李四\", 59, 6666.66), new Employee(101, \"张三\", 18, 9999.99), new Employee(103, \"王五\", 28, 3333.33), new Employee(104, \"赵六\", 8, 7777.77), new Employee(104, \"赵六\", 8, 7777.77), new Employee(104, \"赵六\", 8, 7777.77), new Employee(105, \"田七\", 38, 5555.55) ); /* 筛选与切片 filter——接收 Lambda ， 从流中排除某些元素。 limit——截断流，使其元素不超过给定数量。 skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补 distinct——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素 */ //内部迭代：迭代操作 Stream API 内部完成 @Test public void test2(){ //所有的中间操作不会做任何的处理 Stream stream = emps.stream() .filter((e) -> { System.out.println(\"测试中间操作\"); return e.getAge() it = emps.iterator(); while(it.hasNext()){ System.out.println(it.next()); } } @Test public void test4(){ emps.stream() .filter((e) -> { System.out.println(\"短路！\"); // && || return e.getSalary() >= 5000; }).limit(3) .forEach(System.out::println); } @Test public void test5(){ emps.parallelStream() .filter((e) -> e.getSalary() >= 5000) .skip(2) .forEach(System.out::println); } @Test public void test6(){ emps.stream() .distinct() .forEach(System.out::println); } /* 映射 map——接收 Lambda ， 将元素转换成其他形式或提取信息。接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。 flatMap——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流 */ @Test public void test1(){ Stream str = emps.stream() .map((e) -> e.getName()); System.out.println(\"-------------------------------------------\"); List strList = Arrays.asList(\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"); Stream stream = strList.stream() .map(String::toUpperCase); stream.forEach(System.out::println); Stream> stream2 = strList.stream() .map(TestStreamAPI1::filterCharacter); stream2.forEach((sm) -> { sm.forEach(System.out::println); }); System.out.println(\"---------------------------------------------\"); Stream stream3 = strList.stream() .flatMap(TestStreamAPI1::filterCharacter); stream3.forEach(System.out::println); } public static Stream filterCharacter(String str){ List list = new ArrayList<>(); for (Character ch : str.toCharArray()) { list.add(ch); } return list.stream(); } /* sorted()——自然排序 sorted(Comparator com)——定制排序 */ @Test public void test2(){ emps.stream() .map(Employee::getName) .sorted() .forEach(System.out::println); System.out.println(\"------------------------------------\"); emps.stream() .sorted((x, y) -> { if(x.getAge() == y.getAge()){ return x.getName().compareTo(y.getName()); }else{ return Integer.compare(x.getAge(), y.getAge()); } }).forEach(System.out::println); } } 终止操作 终止操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是void 查找与匹配 方法 描述 allMatch(Predicate p) 检查是否匹配所有元素 anyMatch(Predicate p) 检查是否至少匹配一个元素 noneMatch(Predicatep) 检查是否没有匹配所有元素 findFirst() 返回第一个元素 findAny() 返回当前流中的任意元素 count() 返回流中元素总数 max(Comparatorc) 返回流中最大值 min(Comparatorc) 返回流中最小值 forEach(Consumerc) 内部迭代(使用Collection 接口需要用户去做迭代，称为外部迭代。相反，Stream API 使用内部迭代——它帮你把迭代做了) public class TestStreamAPI2 { List emps = Arrays.asList( new Employee(102, \"李四\", 59, 6666.66, Employee.Status.BUSY), new Employee(101, \"张三\", 18, 9999.99, Employee.Status.FREE), new Employee(103, \"王五\", 28, 3333.33, Employee.Status.VOCATION), new Employee(104, \"赵六\", 8, 7777.77, Employee.Status.BUSY), new Employee(104, \"赵六\", 8, 7777.77, Employee.Status.FREE), new Employee(104, \"赵七\", 8, 7777.77, Employee.Status.FREE), new Employee(105, \"田七\", 38, 5555.55, Employee.Status.BUSY) ); //3. 终止操作 /* allMatch——检查是否匹配所有元素 anyMatch——检查是否至少匹配一个元素 noneMatch——检查是否没有匹配的元素 findFirst——返回第一个元素 findAny——返回当前流中的任意元素 count——返回流中元素的总个数 max——返回流中最大值 min——返回流中最小值 */ @Test public void test1(){ boolean bl = emps.stream() .allMatch((e) -> e.getStatus().equals(Employee.Status.BUSY)); System.out.println(bl); boolean bl1 = emps.stream() .anyMatch((e) -> e.getStatus().equals(Employee.Status.BUSY)); System.out.println(bl1); boolean bl2 = emps.stream() .noneMatch((e) -> e.getStatus().equals(Employee.Status.BUSY)); System.out.println(bl2); } @Test public void test2(){ Optional op = emps.stream() .sorted((e1, e2) -> Double.compare(e1.getSalary(), e2.getSalary())) .findFirst();//有可能为空即封装到Optional里 System.out.println(op.get()); System.out.println(\"--------------------------------\"); Optional op2 = emps.parallelStream() .filter((e) -> e.getStatus().equals(Employee.Status.FREE)) .findAny(); System.out.println(op2.get()); } @Test public void test3(){ long count = emps.stream() .filter((e) -> e.getStatus().equals(Employee.Status.FREE)) .count(); System.out.println(count); Optional op = emps.stream() .map(Employee::getSalary) .max(Double::compare); System.out.println(op.get()); Optional op2 = emps.stream() .min((e1, e2) -> Double.compare(e1.getSalary(), e2.getSalary())); System.out.println(op2.get()); } //注意：流进行了终止操作后，不能再次使用 @Test public void test4(){ Stream stream = emps.stream() .filter((e) -> e.getStatus().equals(Employee.Status.FREE)); long count = stream.count(); stream.map(Employee::getSalary) .max(Double::compare); } } 归约 方法 描述 reduce(T iden, BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。返回T reduce(BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。返回Optional 备注：map 和reduce 的连接通常称为map-reduce 模式，因Google 用它来进行网络搜索而出名。 /* 归约 reduce(T identity, BinaryOperator) / reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值。 */ @Test public void test1(){ List list = Arrays.asList(1,2,3,4,5,6,7,8,9,10); Integer sum = list.stream() .reduce(0, (x, y) -> x + y); System.out.println(sum); System.out.println(\"----------------------------------------\"); Optional op = emps.stream() .map(Employee::getSalary) .reduce(Double::sum); System.out.println(op.get()); } //需求：搜索名字中 “六” 出现的次数 @Test public void test2(){ Optional sum = emps.stream() .map(Employee::getName) .flatMap(TestStreamAPI1::filterCharacter) .map((ch) -> { if(ch.equals('六')) return 1; else return 0; }).reduce(Integer::sum); System.out.println(sum.get()); } 收集 方法 描述 collect(Collector c) 将流转换为其他形式。接收一个Collector接口的实现，用于给Stream中元素做汇总的方法 Collector 接口中方法的实现决定了如何对流执行收集操作(如收集到List、Set、Map)。但是Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表: 方法 返回类型 作用 toList List 把流中元素收集到List 示例 Listemps=list.stream().collect(Collectors.toList()); toSet Set 把流中元素收集到Set 示例 Setemps=list.stream().collect(Collectors.toSet()); toCollection Collection 把流中元素收集到创建的集合 示例 Collectionemps=list.stream().collect(Collectors.toCollection(ArrayList::new)); counting Long 计算流中元素的个数 示例 longcount=list.stream().collect(Collectors.counting()); summingInt Integer 对流中元素的整数属性求和 示例 inttotal=list.stream().collect(Collectors.summingInt(Employee::getSalary)); averagingInt Double 计算流中元素Integer属性的平均值 示例 doubleavg=list.stream().collect(Collectors.averagingInt(Employee::getSalary)); summarizingInt IntSummaryStatistics 收集流中Integer属性的统计值。如：平均值 示例 IntSummaryStatisticsiss=list.stream().collect(Collectors.summarizingInt(Employee::getSalary)); joining String 连接流中每个字符串 示例 Stringstr=list.stream().map(Employee::getName).collect(Collectors.joining()); maxBy Optional 根据比较器选择最大值 示例 Optionalmax=list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary))); minBy Optional 根据比较器选择最小值 示例 Optionalmin=list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary))); reducing 归约产生的类型 从一个作为累加器的初始值开始，利用BinaryOperator与流中元素逐个结合，从而归约成单个值 示例 inttotal=list.stream().collect(Collectors.reducing(0,Employee::getSalar,Integer::sum)); collectingAndThen 转换函数返回的类型 包裹另一个收集器，对其结果转换函数 示例 inthow=list.stream().collect(Collectors.collectingAndThen(Collectors.toList(),List::size)); groupingBy Map> 根据某属性值对流分组，属性为K，结果为V 示例 Map> map= list.stream().collect(Collectors.groupingBy(Employee::getStatus)); partitioningBy Map> 根据true或false进行分区 示例 Map>vd=list.stream().collect(Collectors.partitioningBy(Employee::getManage)); //collect——将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法 @Test public void test3(){ List list = emps.stream() .map(Employee::getName) .collect(Collectors.toList()); list.forEach(System.out::println); System.out.println(\"----------------------------------\"); Set set = emps.stream() .map(Employee::getName) .collect(Collectors.toSet()); set.forEach(System.out::println); System.out.println(\"----------------------------------\"); HashSet hs = emps.stream() .map(Employee::getName) .collect(Collectors.toCollection(HashSet::new)); hs.forEach(System.out::println); } @Test public void test4(){ Optional max = emps.stream() .map(Employee::getSalary) .collect(Collectors.maxBy(Double::compare)); System.out.println(max.get()); Optional op = emps.stream() .collect(Collectors.minBy((e1, e2) -> Double.compare(e1.getSalary(), e2.getSalary()))); System.out.println(op.get()); Double sum = emps.stream() .collect(Collectors.summingDouble(Employee::getSalary)); System.out.println(sum); Double avg = emps.stream() .collect(Collectors.averagingDouble(Employee::getSalary)); System.out.println(avg); Long count = emps.stream() .collect(Collectors.counting()); System.out.println(count); System.out.println(\"--------------------------------------------\"); DoubleSummaryStatistics dss = emps.stream() .collect(Collectors.summarizingDouble(Employee::getSalary)); System.out.println(dss.getMax()); } //分组 @Test public void test5(){ Map> map = emps.stream() .collect(Collectors.groupingBy(Employee::getStatus)); System.out.println(map); } //多级分组 @Test public void test6(){ Map>> map = emps.stream() .collect(Collectors.groupingBy(Employee::getStatus, Collectors.groupingBy((e) -> { if(e.getAge() >= 60) return \"老年\"; else if(e.getAge() >= 35) return \"中年\"; else return \"成年\"; }))); System.out.println(map); } //分区 @Test public void test7(){ Map> map = emps.stream() .collect(Collectors.partitioningBy((e) -> e.getSalary() >= 5000)); System.out.println(map); } // @Test public void test8(){ String str = emps.stream() .map(Employee::getName) .collect(Collectors.joining(\",\" , \"----\", \"----\")); System.out.println(str); } @Test public void test9(){ Optional sum = emps.stream() .map(Employee::getSalary) .collect(Collectors.reducing(Double::sum)); System.out.println(sum.get()); } Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-07 10:22:58 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/java_version/java8_Stream并行流与串行流.html":{"url":"Chapter1/java_version/java8_Stream并行流与串行流.html","title":"并行流与串行流","keywords":"","body":"并行流与串行流并行流与串行流 并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。Stream API 可以声明性地通过 parallel() 与sequential() 在并行流与顺序流之间进行切换 //求和 @Test public void test3() { long start = System.currentTimeMillis(); Long sum = LongStream.rangeClosed(0L, 10000000000L) .parallel() //切换并行 .sum(); System.out.println(sum); long end = System.currentTimeMillis(); System.out.println(\"耗费的时间为: \" + (end - start)); } Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-07 09:34:59 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/java_version/java8_Optional.html":{"url":"Chapter1/java_version/java8_Optional.html","title":"Optional","keywords":"","body":"OptionalOptional 容器类,用于尽量避免空指针异常 Optional.of(T t) : 创建一个 Optional 实例 Optional.empty() : 创建一个空的 Optional 实例 Optional.ofNullable(T t):若 t 不为 null,创建 Optional 实例,否则创建空实例 isPresent() : 判断是否包含值 orElse(T t) : 如果调用对象包含值，返回该值，否则返回t orElseGet(Supplier s) :如果调用对象包含值，返回该值，否则返回 s 获取的值 map(Function f): 如果有值对其处理，并返回处理后的Optional，否则返回 Optional.empty() flatMap(Function mapper):与 map 类似，要求返回值必须是Optional //测试类1 public class NewMan { private Optional godness = Optional.empty(); private Godness god; public Optional getGod() { return Optional.of(god); } public NewMan() { } public NewMan(Optional godness) { this.godness = godness; } public Optional getGodness() { return godness; } public void setGodness(Optional godness) { this.godness = godness; } @Override public String toString() { return \"NewMan [godness=\" + godness + \"]\"; } } //测试类2 public class NewMan { private Optional godness = Optional.empty(); private Godness god; public Optional getGod() { return Optional.of(god); } public NewMan() { } public NewMan(Optional godness) { this.godness = godness; } public Optional getGodness() { return godness; } public void setGodness(Optional godness) { this.godness = godness; } @Override public String toString() { return \"NewMan [godness=\" + godness + \"]\"; } } //测试3 public class Godness { private String name; public Godness() { } public Godness(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"Godness [name=\" + name + \"]\"; } } //Optional示例 public class TestOptional { @Test public void test4() { Optional op = Optional.of(new Employee(101, \"张三\", 18, 9999.99)); Optional op2 = op.map(Employee::getName); System.out.println(op2.get()); Optional op3 = op.flatMap((e) -> Optional.of(e.getName())); System.out.println(op3.get()); } @Test public void test3() { Optional op = Optional.ofNullable(new Employee()); if (op.isPresent()) {//判断是否有值 System.out.println(op.get()); } Employee emp = op.orElse(new Employee(\"张三\")); System.out.println(emp); Employee emp2 = op.orElseGet(() -> new Employee()); System.out.println(emp2); } @Test public void test2() { Optional op = Optional.ofNullable(new Employee());//of 和 empty的综合 System.out.println(op.get()); Optional op2 = Optional.empty(); System.out.println(op2.get()); } @Test public void test1() { Optional op = Optional.of(new Employee()); Employee emp = op.get(); System.out.println(emp); } @Test public void test5() { Man man = new Man(); String name = getGodnessName(man); System.out.println(name); } //需求：获取一个名字 public String getGodnessName(Man man) { if (man != null) { Godness g = man.getGod(); if (g != null) { return g.getName(); } } return \"赵小二\"; } //运用 Optional 的实体类 @Test public void test6() { Optional godness = Optional.ofNullable(new Godness(\"林志玲\")); Optional op = Optional.ofNullable(new NewMan(godness)); String name = getGodnessName2(op); System.out.println(name); } public String getGodnessName2(Optional man) { return man.orElse(new NewMan()) .getGodness() .orElse(new Godness(\"赵小二\")) .getName(); } } Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-07 13:36:40 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/java_version/java8_接口默认和静态方法.html":{"url":"Chapter1/java_version/java8_接口默认和静态方法.html","title":"接口默认方法和静态方法","keywords":"","body":"接口中默认方法和静态方法默认方法静态方法接口中默认方法和静态方法 默认方法 Java 8中允许接口中包含具有具体实现的方法，该方法称为“默认方法”，默认方法使用 default 关键字修饰接口默认方法的”类优先”原则:若一个接口中定义了一个默认方法，而另外一个父类或接口中又定义了一个同名的方法时 选择父类中的方法。如果一个父类提供了具体的实现，那么接口中具有相同名称和参数的默认方法会被忽略。 接口冲突。如果一个父接口提供一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法（不管方法是否是默认方法），那么必须覆盖该方法来解决冲突 静态方法 Java8中,接口允许添加静态方法 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-07 13:54:13 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/java_version/java8_新时间日期.html":{"url":"Chapter1/java_version/java8_新时间日期.html","title":"新时间日期API","keywords":"","body":"新时间日期API旧SimpleDateFormat的线程安全问题LocalDate、LocalTime、LocalDateTimeInstant 时间戳Duration 和 Period日期的操作解析和格式化时区的处理与传统日期处理的转换新时间日期API 旧SimpleDateFormat的线程安全问题 多个线程同时格式化,会抛异常 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyyMMdd\"); Callable task = new Callable() { @Override public Date call() throws Exception { return sdf.parse(\"20161121\"); } }; ExecutorService pool = Executors.newFixedThreadPool(10); List> results = new ArrayList<>(); for (int i = 0; i future : results) { System.out.println(future.get()); } pool.shutdown(); 解决线程安全问题 Callable task = new Callable() { @Override public Date call() throws Exception { return DateFormatThreadLocal.convert(\"20161121\"); } }; ExecutorService pool = Executors.newFixedThreadPool(10); List> results = new ArrayList<>(); for (int i = 0; i future : results) { System.out.println(future.get()); } pool.shutdown(); //其中DateFormatThreadLocal public class DateFormatThreadLocal { private static final ThreadLocal df = new ThreadLocal() { protected DateFormat initialValue() { return new SimpleDateFormat(\"yyyyMMdd\"); } }; public static final Date convert(String source) throws ParseException { return df.get().parse(source); } } LocalDate则不存在线程安全问题 DateTimeFormatter dtf = DateTimeFormatter.ofPattern(\"yyyyMMdd\"); Callable task = new Callable() { @Override public LocalDate call() throws Exception { LocalDate ld = LocalDate.parse(\"20161121\", dtf); return ld; } }; ExecutorService pool = Executors.newFixedThreadPool(10); List> results = new ArrayList<>(); for (int i = 0; i future : results) { System.out.println(future.get()); } pool.shutdown(); LocalDate、LocalTime、LocalDateTime LocalDate、LocalTime、LocalDateTime 类的实例是不可变的对象，分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的日期或时间，并不包含当前的时间信息。也不包含与时区相关的信息 方法 描述 示例 now() 静态方法，根据当前时间创建对象 LocalDate localDate = LocalDate.now()LocalTime localTime = LocalTime.now()LocalDateTime localDateTime = LocalDateTime.now() of() 静态方法，根据指定日期/时间创建对象 LocalDate localDate = LocalDate.of(2016, 10, 26)LocalTime localTime = LocalTime.of(02, 22, 56)LocalDateTime localDateTime = LocalDateTime.of(2016, 10, 26, 12, 10, 55) plusDaysplusWeeksplusMonthsplusYears 向当前 LocalDate 对象添加几天、几周、几个月、几年 minusDaysminusWeeksminusMonthsminusYears 从当前 LocalDate 对象减去几天、几周、几个月、几年 plusminus 添加或减少一个 Duration 或 Period withDayOfMonthwithDayOfYearwithMonthwithYear 将月份天数、年份天数、月份、年份修改为指定的值并返回新的LocalDate 对象 getDayOfMonth 获得月份天数(1-31) getDayOfYear 获得年份天数(1-366) getDayOfWeek 获得星期几(返回一个 DayOfWeek枚举值) getMonth 获得月份, 返回一个 Month 枚举值 getMonthValue 获得月份(1-12) getYear 获得年份 until 获得两个日期之间的 Period 对象，或者指定 ChronoUnits 的数字 isBeforeisAfter 比较两个 LocalDate isLeapYear 判断是否是闰年 Instant 时间戳 用于“时间戳”的运算。它是以Unix元年(传统的设定为UTC时区1970年1月1日午夜时分)开始所经历的描述进行运算 @Test public void test2() { Instant ins = Instant.now(); //默认使用 UTC 时区 System.out.println(ins); OffsetDateTime odt = ins.atOffset(ZoneOffset.ofHours(8));//指定时区 System.out.println(odt); System.out.println(ins.toEpochMilli());//转成时间戳 Instant ins2 = Instant.ofEpochSecond(5);//设置Instant/秒 System.out.println(ins2); } Duration 和 Period Duration:用于计算两个“时间”间隔 Period:用于计算两个“日期”间隔 @Test public void test3() { Instant ins1 = Instant.now(); System.out.println(\"--------------------\"); try { Thread.sleep(1000); } catch (InterruptedException e) { } Instant ins2 = Instant.now(); Duration between = Duration.between(ins1, ins2); System.out.println(\"所耗费时间为：\" + between); System.out.println(\"所耗费时间为：\" + between.getSeconds()); System.out.println(\"所耗费时间为：\" + between.toMillis()); System.out.println(\"----------------------------------\"); LocalDate ld1 = LocalDate.now(); LocalDate ld2 = LocalDate.of(2011, 1, 1); Period pe = Period.between(ld2, ld1); System.out.println(pe.getYears()); System.out.println(pe.getMonths()); System.out.println(pe.getDays()); Period until = ld2.until(ld1);//同between System.out.println(until.getYears()); } 日期的操作 TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整到“下个周日”等操作。 TemporalAdjusters : 该类通过静态方法提供了大量的常用 TemporalAdjuster 的实现 @Test public void test4() { LocalDateTime ldt = LocalDateTime.now(); System.out.println(ldt); LocalDateTime ldt2 = ldt.withDayOfMonth(10); System.out.println(ldt2); LocalDateTime ldt3 = ldt.with(TemporalAdjusters.next(DayOfWeek.SUNDAY)); System.out.println(ldt3); //自定义：下一个工作日 LocalDateTime ldt5 = ldt.with((l) -> { LocalDateTime ldt4 = (LocalDateTime) l; DayOfWeek dow = ldt4.getDayOfWeek(); if (dow.equals(DayOfWeek.MONDAY)) { return ldt4.plusDays(7); } else if (dow.equals(DayOfWeek.TUESDAY)) { return ldt4.plusDays(6); } else if (dow.equals(DayOfWeek.SUNDAY)) { return ldt4.plusDays(5); } else if (dow.equals(DayOfWeek.THURSDAY)) { return ldt4.plusDays(4); } else if (dow.equals(DayOfWeek.FRIDAY)) { return ldt4.plusDays(3); } else if (dow.equals(DayOfWeek.SATURDAY)) { return ldt4.plusDays(2); } else { return ldt4.plusDays(1); } }); System.out.println(ldt5); } 解析和格式化 java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法： 预定义的标准格式 语言环境相关的格式 自定义的格式 @Test public void test5() { // DateTimeFormatter dtf = DateTimeFormatter.ISO_LOCAL_DATE; DateTimeFormatter dtf = DateTimeFormatter.ofPattern(\"yyyy年MM月dd日 HH:mm:ss E\"); LocalDateTime ldt = LocalDateTime.now(); String strDate = ldt.format(dtf); System.out.println(strDate); LocalDateTime newLdt = ldt.parse(strDate, dtf); System.out.println(newLdt); } 时区的处理 Java8 中加入了对时区的支持，带时区的时间为分别为： ZonedDateZonedTimeZonedDateTime 其中每个时区都对应着 ID，地区ID都为 “{区域}/{城市}”的格式例如 ：Asia/Shanghai 等 ZoneId：该类中包含了所有的时区信息 getAvailableZoneIds() : 可以获取所有时区时区信息 of(id) : 用指定的时区信息获取 ZoneId 对象 @Test public void test7() { LocalDateTime ldt = LocalDateTime.now(ZoneId.of(\"Asia/Shanghai\")); System.out.println(ldt); ZonedDateTime zdt = ZonedDateTime.now(ZoneId.of(\"US/Pacific\")); System.out.println(zdt); } @Test public void test6() { Set set = ZoneId.getAvailableZoneIds(); set.forEach(System.out::println); } 与传统日期处理的转换 类 To 遗留类 From 遗留类 java.time.Instant java.util.Date Date.from(instant) date.toInstant() java.time.Instant java.sql.Timestamp Timestamp.from(instant) timestamp.toInstant() java.time.ZonedDateTime java.util.GregorianCalendar GregorianCalendar.from(zonedDateTime) cal.toZonedDateTime() java.time.LocalDate java.sql.Time Date.valueOf(localDate) date.toLocalDate() java.time.LocalTime java.sql.Time Date.valueOf(localDate) date.toLocalTime() java.time.LocalDateTime java.sql.Timestamp Timestamp.valueOf(localDateTime) timestamp.toLocalDateTime() java.time.ZoneId java.util.TimeZone Timezone.getTimeZone(id) timeZone.toZoneId() java.time.format.DateTimeFormatter java.text.DateFormat formatter.toFormat() 无 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-07 18:14:27 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/java_version/java8_重复注解与类型注解.html":{"url":"Chapter1/java_version/java8_重复注解与类型注解.html","title":"重复注解与类型注解","keywords":"","body":"重复注解与类型注解重复注解与类型注解 /** * 支持重复注解 */ @Repeatable(MyAnnotations.class) @Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE}) @Retention(RetentionPolicy.RUNTIME) public @interface MyAnnotation { String value() default \"\"; } /** * */ @Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE}) @Retention(RetentionPolicy.RUNTIME) public @interface MyAnnotations { MyAnnotation[] value(); } /** * @description: 测试重复注解 */ public class AnnotatonTest { @Test public void test() throws NoSuchMethodException { Class clazz = AnnotatonTest.class; Method show = clazz.getMethod(\"show\"); MyAnnotation[] annotationsByType = show.getAnnotationsByType(MyAnnotation.class); for (MyAnnotation m : annotationsByType) { System.out.println(m.value()); } } @MyAnnotation(\"thank\") @MyAnnotation(\"you\") public void show(){} } Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-07 18:43:07 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/java_version/java9.html":{"url":"Chapter1/java_version/java9.html","title":"java9","keywords":"","body":"jdk9jdk9 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-06 15:35:15 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/java_version/java10.html":{"url":"Chapter1/java_version/java10.html","title":"java10","keywords":"","body":"jdk10jdk10 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-06 15:35:11 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/java_version/java11.html":{"url":"Chapter1/java_version/java11.html","title":"java11","keywords":"","body":"jdk11jdk11 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-06 15:35:07 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/java_version/java12.html":{"url":"Chapter1/java_version/java12.html","title":"java12","keywords":"","body":"jdk12jdk12 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-06 15:35:02 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/java_version/java13.html":{"url":"Chapter1/java_version/java13.html","title":"java13","keywords":"","body":"jdk13jdk13 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-06 15:34:57 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/java_version/java14.html":{"url":"Chapter1/java_version/java14.html","title":"java814","keywords":"","body":"jdk14jdk14 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-06 15:34:51 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/nio/NIO.html":{"url":"Chapter1/nio/NIO.html","title":"NIO","keywords":"","body":"NIO 介绍NIO 与 IO 的主要区别通道与缓冲区NIO 介绍 Java NIO（New IO）是从Java 1.4版本开始引入的一个新的IO API,可以替代标准的Java IO API.NIO与原来的IO有同样的作用和目的,但是使用的方式完全不同,NIO支持面向缓冲区的、基于通道的IO操作.NIO将以更加高效的方式进行文件的读写操作. NIO 与 IO 的主要区别 IO NIO 面向流(Stream Oriented) 面向缓冲区(Buffer Oriented) 阻塞IO(Blocking IO) 非阻塞IO(NonBlocking IO) 无 选择器(Selectors) 通道与缓冲区 Java NIO系统的核心在于：通道(Channel)和缓冲区(Buffer)。通道表示打开到IO 设备(例如：文件、套接字)的连接。若需要使用NIO 系统，需要获取用于连接IO 设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理.即channel负责传输, buffer负责存储 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-03 13:38:02 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/nio/缓冲区.html":{"url":"Chapter1/nio/缓冲区.html","title":"Buffer(缓冲区)","keywords":"","body":"Buffer(缓冲区)BufferBuffer类型数据存取4个核心属性Buffer的常用方法直接与非直接缓冲区Buffer(缓冲区) Buffer 在 Java NIO 中负责数据的存取。缓冲区就是数组。用于存储不同数据类型的数据 Buffer类型 根据数据类型不同（boolean 除外），提供了相应类型的缓冲区 ByteBuffer CharBuffer ShortBuffer IntBuffer LongBuffer FloatBuffer DoubleBuffer 通过allocate()方法获取缓冲区 数据存取 put() get() 4个核心属性 capacity : 容量，表示缓冲区中最大存储数据的容量。一旦声明不能改变。 limit : 界限，表示缓冲区中可以操作数据的大小。（limit 后数据不能进行读写） position : 位置，表示缓冲区中正在操作数据的位置。 mark : 标记，表示记录当前 position 的位置。可以通过 reset() 恢复到 mark 的位置0 public class TestBuffer { @Test public void test1(){ String str = \"abcde\"; //1. 分配一个指定大小的缓冲区 ByteBuffer buf = ByteBuffer.allocate(1024); System.out.println(\"-----------------allocate()----------------\"); System.out.println(buf.position());//0 System.out.println(buf.limit());//1024 System.out.println(buf.capacity());//1024 //2. 利用 put() 存入数据到缓冲区中 buf.put(str.getBytes()); System.out.println(\"-----------------put()----------------\"); System.out.println(buf.position());//5 System.out.println(buf.limit());//1024 System.out.println(buf.capacity());//1024 //3. 切换读取数据模式 buf.flip(); System.out.println(\"-----------------flip()----------------\"); System.out.println(buf.position());//0 System.out.println(buf.limit());//5 System.out.println(buf.capacity());//1024 //4. 利用 get() 读取缓冲区中的数据 byte[] dst = new byte[buf.limit()]; buf.get(dst); System.out.println(new String(dst, 0, dst.length));//abcde System.out.println(\"-----------------get()----------------\"); System.out.println(buf.position());//5 System.out.println(buf.limit());//5 System.out.println(buf.capacity());//1024 //5. rewind() : 可重复读 buf.rewind(); System.out.println(\"-----------------rewind()----------------\"); System.out.println(buf.position());//0 System.out.println(buf.limit());//5 System.out.println(buf.capacity());//1024 //6. clear() : 清空缓冲区. 但是缓冲区中的数据依然存在，但是处于“被遗忘”状态 buf.clear(); System.out.println(\"-----------------clear()----------------\"); System.out.println(buf.position());//0 System.out.println(buf.limit());//1024 System.out.println(buf.capacity());//1024 System.out.println((char)buf.get());//a } @Test public void test2(){ String str = \"abcde\"; ByteBuffer buf = ByteBuffer.allocate(1024); buf.put(str.getBytes()); buf.flip(); byte[] dst = new byte[buf.limit()]; buf.get(dst, 0, 2); System.out.println(new String(dst, 0, 2));//ab System.out.println(buf.position());//2 //mark() : 标记 buf.mark(); buf.get(dst, 2, 2); System.out.println(new String(dst, 2, 2));//cd System.out.println(buf.position());//4 //reset() : 恢复到 mark 的位置 buf.reset(); System.out.println(buf.position());//2 //判断缓冲区中是否还有剩余数据 if(buf.hasRemaining()){ //获取缓冲区中可以操作的数量 System.out.println(buf.remaining());//3 } } } Buffer的常用方法 IO NIO Buffer clear() 清空缓冲区并返回对缓冲区的引用 Buffer flip() 将缓冲区的界限设置为当前位置，并将当前位置重置为0 int capacity() 返回Buffer 的capacity大小 boolean hasRemaining() 判断缓冲区中是否还有元素 int limit() 返回Buffer 的界限(limit) 的位置 Buffer limit(int n) 将设置缓冲区界限为n, 并返回一个具有新limit 的缓冲区对象 Buffer mark() 对缓冲区设置标记 int position() 返回缓冲区的当前位置position Buffer position(int n) 将设置缓冲区的当前位置为n , 并返回修改后的Buffer 对象 int remaining() 返回position 和limit 之间的元素个数 Buffer reset() 将位置position 转到以前设置的mark 所在的位置 Buffer rewind() 将位置设为为0，取消设置的mark 直接与非直接缓冲区 字节缓冲区要么是直接的，要么是非直接的。如果为直接字节缓冲区，则Java 虚拟机会尽最大努力直接在此缓冲区上执行本机I/O 操作。也就是说，在每次调用基础操作系统的一个本机I/O 操作之前（或之后），虚拟机都会尽量避免将缓冲区的内容复制到中间缓冲区中（或从中间缓冲区中复制内容）。 直接字节缓冲区可以通过调用此类的allocateDirect() 工厂方法来创建。此方法返回的缓冲区进行分配和取消分配所需成本通常高于非直接缓冲区。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，它们对应用程序的内存需求量造成的影响可能并不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的本机I/O 操作影响的大型、持久的缓冲区。一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好处时分配它们。 直接字节缓冲区还可以通过FileChannel 的map() 方法将文件区域直接映射到内存中来创建。该方法返回MappedByteBuffer。Java 平台的实现有助于通过JNI 从本机代码创建直接字节缓冲区。如果以上这些缓冲区中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域不会更改该缓冲区的内容，并且将会在访问期间或稍后的某个时间导致抛出不确定的异常。 字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其isDirect()方法来确定。提供此方法是为了能够在性能关键型代码中执行显式缓冲区管理。 非直接缓冲区：通过 allocate() 方法分配缓冲区，将缓冲区建立在 JVM 的内存中 直接缓冲区：通过 allocateDirect() 方法分配直接缓冲区，将缓冲区建立在物理内存中。可以提高效率 //分配直接缓冲区 ByteBuffer buf = ByteBuffer.allocateDirect(1024); System.out.println(buf.isDirect());//true Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-03 13:37:51 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/nio/通道.html":{"url":"Chapter1/nio/通道.html","title":"Channel(通道)","keywords":"","body":"Channel(通道)Channel通道的主要实现类获取通道的方式通道之间的数据传输字符集：CharsetChannel(通道) Channel 用于源节点与目标节点的连接。在 Java NIO 中负责缓冲区中数据的传输。Channel 本身不存储数据，因此需要配合缓冲区进行传输 通道的主要实现类 java.nio.channels.Channel 接口： FileChannel : 用于读取、写入、映射和操作文件的通道 SocketChannel : 通过TCP 读写网络中的数据 ServerSocketChannel : 可以监听新进来的TCP 连接，对每一个新进来的连接都会创建一个SocketChannel DatagramChannel : 通过UDP 读写网络中的数据通道 获取通道的方式 Java 针对支持通道的类提供了 getChannel() 方法 本地 IO： FileInputStream/FileOutputStream RandomAccessFile 网络IO： Socket ServerSocket DatagramSocket 在 JDK 1.7 中的 NIO.2 针对各个通道提供了静态方法 open() 在 JDK 1.7 中的 NIO.2 的 Files 工具类的 newByteChannel() public class TestChannel { //使用直接缓冲区完成文件的复制(内存映射文件) @Test public void test2() throws IOException{//2127-1902-1777 long start = System.currentTimeMillis(); FileChannel inChannel = FileChannel.open(Paths.get(\"d:/1.mkv\"), StandardOpenOption.READ); FileChannel outChannel = FileChannel.open(Paths.get(\"d:/2.mkv\"), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE); //内存映射文件 MappedByteBuffer inMappedBuf = inChannel.map(MapMode.READ_ONLY, 0, inChannel.size()); MappedByteBuffer outMappedBuf = outChannel.map(MapMode.READ_WRITE, 0, inChannel.size()); //直接对缓冲区进行数据的读写操作 byte[] dst = new byte[inMappedBuf.limit()]; inMappedBuf.get(dst); outMappedBuf.put(dst); inChannel.close(); outChannel.close(); long end = System.currentTimeMillis(); System.out.println(\"耗费时间为：\" + (end - start)); } //利用通道完成文件的复制（非直接缓冲区） @Test public void test1(){//10874-10953 long start = System.currentTimeMillis(); FileInputStream fis = null; FileOutputStream fos = null; //①获取通道 FileChannel inChannel = null; FileChannel outChannel = null; try { fis = new FileInputStream(\"d:/1.mkv\"); fos = new FileOutputStream(\"d:/2.mkv\"); inChannel = fis.getChannel(); outChannel = fos.getChannel(); //②分配指定大小的缓冲区 ByteBuffer buf = ByteBuffer.allocate(1024); //③将通道中的数据存入缓冲区中 while(inChannel.read(buf) != -1){ buf.flip(); //切换读取数据的模式 //④将缓冲区中的数据写入通道中 outChannel.write(buf); buf.clear(); //清空缓冲区 } } catch (IOException e) { e.printStackTrace(); } finally { if(outChannel != null){ try { outChannel.close(); } catch (IOException e) { e.printStackTrace(); } } if(inChannel != null){ try { inChannel.close(); } catch (IOException e) { e.printStackTrace(); } } if(fos != null){ try { fos.close(); } catch (IOException e) { e.printStackTrace(); } } if(fis != null){ try { fis.close(); } catch (IOException e) { e.printStackTrace(); } } } long end = System.currentTimeMillis(); System.out.println(\"耗费时间为：\" + (end - start)); } } 通道之间的数据传输 transferFrom() transferTo() ```java public class TestChannel{ //通道之间的数据传输(直接缓冲区) @Test public void test3() throws IOException{ FileChannel inChannel = FileChannel.open(Paths.get(\"d:/1.mkv\"), StandardOpenOption.READ); FileChannel outChannel = FileChannel.open(Paths.get(\"d:/2.mkv\"), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE); // inChannel.transferTo(0, inChannel.size(), outChannel); outChannel.transferFrom(inChannel, 0, inChannel.size()); inChannel.close(); outChannel.close(); } } ## 分散(Scatter)与聚集(Gather) * 分散读取（Scattering Reads）：将通道中的数据分散到多个缓冲区中 * 聚集写入（Gathering Writes）：将多个缓冲区中的数据聚集到通道中 ```java public class TestChannel{ //分散和聚集 @Test public void test4() throws IOException{ RandomAccessFile raf1 = new RandomAccessFile(\"1.txt\", \"rw\"); //1. 获取通道 FileChannel channel1 = raf1.getChannel(); //2. 分配指定大小的缓冲区 ByteBuffer buf1 = ByteBuffer.allocate(100); ByteBuffer buf2 = ByteBuffer.allocate(1024); //3. 分散读取 ByteBuffer[] bufs = {buf1, buf2}; channel1.read(bufs); for (ByteBuffer byteBuffer : bufs) { byteBuffer.flip(); } System.out.println(new String(bufs[0].array(), 0, bufs[0].limit())); System.out.println(\"-----------------\"); System.out.println(new String(bufs[1].array(), 0, bufs[1].limit())); //4. 聚集写入 RandomAccessFile raf2 = new RandomAccessFile(\"2.txt\", \"rw\"); FileChannel channel2 = raf2.getChannel(); channel2.write(bufs); } } 字符集：Charset 编码：字符串 -> 字节数组 解码：字节数组 -> 字符串 public class TestChannel{ //字符集 @Test public void test6() throws IOException{ Charset cs1 = Charset.forName(\"GBK\"); //获取编码器 CharsetEncoder ce = cs1.newEncoder(); //获取解码器 CharsetDecoder cd = cs1.newDecoder(); CharBuffer cBuf = CharBuffer.allocate(1024); cBuf.put(\"天王盖地虎！\"); cBuf.flip(); //编码 ByteBuffer bBuf = ce.encode(cBuf); for (int i = 0; i map = Charset.availableCharsets(); Set> set = map.entrySet(); for (Entry entry : set) { System.out.println(entry.getKey() + \"=\" + entry.getValue()); } } } Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-03 13:37:20 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/nio/网络通信.html":{"url":"Chapter1/nio/网络通信.html","title":"网络通信","keywords":"","body":"网络通信使用 NIO 完成网络通信的三个核心：阻塞式示例非阻塞式选择器(Selector)socketChannel serverSocketChannel非阻塞式示例代码管道(Pip)网络通信 传统的IO 流都是阻塞式的。也就是说，当一个线程调用read() 或write() 时，该线程被阻塞，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务。因此，在完成网络通信进行IO 操作时，由于线程会阻塞，所以服务器端必须为每个客户端都提供一个独立的线程进行处理，当服务器端需要处理大量客户端时，性能急剧下降。 Java NIO 是非阻塞模式的。当线程从某通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。线程通常将非阻塞IO 的空闲时间用于在其他通道上执行IO 操作，所以单独的线程可以管理多个输入和输出通道。因此，NIO 可以让服务器端使用一个或有限几个线程来同时处理连接到服务器端的所有客户端 使用 NIO 完成网络通信的三个核心： 通道（Channel）：负责连接 java.nio.channels.Channel 接口： SelectableChannel SocketChannelServerSocketChannelDatagramChannelPipe.SinkChannelPipe.SourceChannel 缓冲区（Buffer）：负责数据的存取 选择器（Selector）：是 SelectableChannel 的多路复用器。用于监控 SelectableChannel 的 IO 状况 阻塞式示例 详见Githubjava-learning项目 非阻塞式 选择器(Selector) 选择器（Selector）是SelectableChannle 对象的多路复用器，Selector 可以同时监控多个SelectableChannel 的IO 状况，也就是说，利用Selector 可使一个单独的线程管理多个Channel。Selector 是非阻塞IO 的核心 创建Selector ：通过调用Selector.open() 方法创建一个Selector。 向选择器注册通道：SelectableChannel.register(Selector sel, int ops) 当调用register(Selector sel, int ops) 将通道注册选择器时，选择器对通道的监听事件，需要通过第二个参数ops 指定 可以监听的事件类型（可使用SelectionKey 的四个常量表示）： 读: SelectionKey.OP_READ （1）写: SelectionKey.OP_WRITE （4）连接: SelectionKey.OP_CONNECT（8）接收: SelectionKey.OP_ACCEPT （16） 若注册时不止监听一个事件，则可以使用“位或”操作符连接 socketChannel serverSocketChannel非阻塞式示例代码 详见Githubjava-learning项目 管道(Pip) Java NIO 管道是2个线程之间的单向数据连接。 Pipe有一个source通道和一个sink通道。数据会 被写到sink通道，从source通道读取 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-03 13:36:32 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/nio/NIO2.html":{"url":"Chapter1/nio/NIO2.html","title":"NIO.2","keywords":"","body":"Path与PathsFiles类自动资源管理Path与Paths java.nio.file.Path 接口代表一个平台无关的平台路径，描述了目 录结构中文件的位置。 Paths 提供的 get() 方法用来获取 Path 对象： Path get(String first, String … more) : 用于将多个字符串串连成路径。 Path 常用方法： boolean endsWith(String path) : 判断是否以 path 路径结束boolean startsWith(String path) : 判断是否以 path 路径开始boolean isAbsolute() : 判断是否是绝对路径Path getFileName() : 返回与调用 Path 对象关联的文件名Path getName(int idx) : 返回的指定索引位置 idx 的路径名称int getNameCount() : 返回Path 根目录后面元素的数量Path getParent() ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径Path getRoot() ：返回调用 Path 对象的根路径Path resolve(Path p) :将相对路径解析为绝对路径Path toAbsolutePath() : 作为绝对路径返回调用 Path 对象String toString() ： 返回调用 Path 对象的字符串表示形式 Files类 java.nio.file.Files 用于操作文件或目录的工具类 Files常用方法： Path copy(Path src, Path dest, CopyOption … how) : 文件的复制Path createDirectory(Path path, FileAttribute … attr) : 创建一个目录Path createFile(Path path, FileAttribute … arr) : 创建一个文件void delete(Path path) : 删除一个文件Path move(Path src, Path dest, CopyOption…how) : 将 src 移动到 dest 位置long size(Path path) : 返回 path 指定文件的大小 Files常用方法：用于判断 boolean exists(Path path, LinkOption … opts) : 判断文件是否存在boolean isDirectory(Path path, LinkOption … opts) : 判断是否是目录boolean isExecutable(Path path) : 判断是否是可执行文件boolean isHidden(Path path) : 判断是否是隐藏文件boolean isReadable(Path path) : 判断文件是否可读boolean isWritable(Path path) : 判断文件是否可写boolean notExists(Path path, LinkOption … opts) : 判断文件是否不存在public static A readAttributes(Path path,Class type,LinkOption... options) : 获取与 path 指定的文件相关联的属性 Files常用方法：用于操作内容 SeekableByteChannel newByteChannel(Path path, OpenOption…how) : 获取与指定文件的连接，how 指定打开方式DirectoryStream newDirectoryStream(Path path) : 打开 path 指定的目录InputStream newInputStream(Path path, OpenOption…how):获取 InputStream 对象OutputStream newOutputStream(Path path, OpenOption…how) : 获取 OutputStream 对象 自动资源管理 Java 7 增加了一个新特性，该特性提供了另外 一种管理资源的方式，这种方式能自动关闭文 件。这个特性有时被称为自动资源管理 (Automatic Resource Management, ARM)， 该特 性以 try 语句的扩展版为基础。自动资源管理 主要用于，当不再需要文件（或其他资源）时， 可以防止无意中忘记释放它们注意：① try 语句中声明的资源被隐式声明为 final ，资源的作用局限于带资源的 try 语句② 可以在一条 try 语句中管理多个资源，每个资源以“;” 隔开即可。③ 需要关闭的资源，必须实现了 AutoCloseable 接口或其自接口 Closeable Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-03 13:35:45 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/juc/JUC.html":{"url":"Chapter1/juc/JUC.html","title":"JUC","keywords":"","body":"JAVA并发包JUC(java.util.concurrent包)JAVA并发包JUC(java.util.concurrent包) 在 Java 5.0 提供了 java.util.concurrent （简称 JUC ）包，在此包中增加了在并发编程中很常用 的实用工具类，用于定义类似于线程的自定义子 系统，包括线程池、异步 IO 和轻量级任务框架。 提供可调的、灵活的线程池。还提供了设计用于 多线程上下文中的 Collection 实现等 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-03 13:42:51 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/juc/1_volatile.html":{"url":"Chapter1/juc/1_volatile.html","title":"volatile","keywords":"","body":"volatile关键字内存可见性volatilevolatile关键字 内存可见性 内存可见性（Memory Visibility）是指当某个线程正在使用对象状态而另一个线程在同时修改该状态，需要确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。 可见性错误是指当读操作与写操作在不同的线程中执行时，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。 我们可以通过同步来保证对象被安全地发布。除此之外我们也可以使用一种更加轻量级的 volatile 变量 volatile Java 提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他线程。可以将 volatile 看做一个轻量级的锁，但是又与 锁有些不同： 对于多线程，不是一种互斥关系 不能保证变量状态的“原子性操作” /* * 一、volatile 关键字：当多个线程进行操作共享数据时，可以保证内存中的数据可见。 * 相较于 synchronized 是一种较为轻量级的同步策略。 * * 注意： * 1. volatile 不具备“互斥性” * 2. volatile 不能保证变量的“原子性” */ public class TestVolatile { public static void main(String[] args) { ThreadDemo td = new ThreadDemo(); new Thread(td).start(); while(true){ if(td.isFlag()){ //如果不加volatile,则以下 ---- 不会打印 System.out.println(\"------------------\"); break; } } } } class ThreadDemo implements Runnable { private volatile boolean flag = false; @Override public void run() { try { Thread.sleep(200); } catch (InterruptedException e) { } flag = true; System.out.println(\"flag=\" + isFlag()); } public boolean isFlag() { return flag; } public void setFlag(boolean flag) { this.flag = flag; } Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-03 14:04:03 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/juc/2_原子变量与CAS算法.html":{"url":"Chapter1/juc/2_原子变量与CAS算法.html","title":"原子变量与CAS","keywords":"","body":"原子变量CAS算法模拟CAS算法CAS算法的缺点原子变量 类的小工具包，支持在单个变量上解除锁的线程安全编程。事实上，此包中的类可将 volatile 值、字段和数组元素的概念扩展到那些也提供原子条件更新操作的类。 类 AtomicBoolean、AtomicInteger、AtomicLong 和 AtomicReference 的实例各自提供对相应类型单个变量的访问和更新。每个类也为该类型提供适当的实用工具方法。 AtomicIntegerArray、AtomicLongArray 和 AtomicReferenceArray 类进一步扩展了原子操作，对这些类型的数组提供了支持。这些类在为其数组元素提供 volatile 访问语义方面也引人注目，这对于普通数组来说是不受支持的。 核心方法：boolean compareAndSet(expectedValue, updateValue) java.util.concurrent.atomic 包下提供了一些原子操作的常用类: AtomicBoolean 、AtomicInteger 、AtomicLong 、 AtomicReferenceAtomicIntegerArray 、AtomicLongArrayAtomicMarkableReferenceAtomicReferenceArrayAtomicStampedReference CAS算法 CAS (Compare-And-Swap) 是一种硬件对并发的支持，针对多处理器操作而设计的处理器中的一种特殊指令，用于管理对共享数据的并发访问。 CAS 是一种无锁的非阻塞算法的实现。 CAS 包含了 3 个操作数： 需要读写的内存值 V 进行比较的值 A 拟写入的新值 B 当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值，否则不会执行任何操作 public class TestAtomicDemo { public static void main(String[] args) { AtomicDemo ad = new AtomicDemo(); for (int i = 0; i 模拟CAS算法 /* * 模拟 CAS 算法 */ public class TestCompareAndSwap { public static void main(String[] args) { final CompareAndSwap cas = new CompareAndSwap(); for (int i = 0; i CAS算法的缺点 循环时间长开销很大： 我们可以看到getAndAddInt方法执行时，如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。 只能保证一个共享变量的原子操作： 当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。 ABA问题 如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效讲解博客链接 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-03 16:14:14 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/juc/3_ConcurrentHashMap.html":{"url":"Chapter1/juc/3_ConcurrentHashMap.html","title":"ConcurrentHashMap","keywords":"","body":"ConcurrentHashMapConcurrentHashMap Java 5.0 在 java.util.concurrent 包中提供了多种并发容器类来改进同步容器的性能。 ConcurrentHashMap 同步容器类是Java 5 增加的一个线程安全的哈希表。对于多线程的操作，介于 HashMap 与 Hashtable 之间。内部采用“锁分段”机制替代 Hashtable 的独占锁。进而提高性能。 此包还提供了设计用于多线程上下文中的 Collection 实现：ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、CopyOnWriteArrayList 和 CopyOnWriteArraySet。当期望许多线程访问一个给定 collection 时，ConcurrentHashMap 通常优于同步的 HashMap，ConcurrentSkipListMap 通常优于同步的 TreeMap。当期望的读数和遍历远远大于列表的更新数时，CopyOnWriteArrayList 优于同步的 ArrayList。 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-03 17:31:06 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/juc/4_CountDownLatch.html":{"url":"Chapter1/juc/4_CountDownLatch.html","title":"CountDownLatch","keywords":"","body":"CountDownLatch 闭锁CountDownLatch 闭锁 Java 5.0 在 java.util.concurrent 包中提供了多种并发容器类来改进同步容器的性能。 CountDownLatch 一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。 闭锁可以延迟线程的进度直到其到达终止状态，闭锁可以用来确保某些活动直到其他活动都完成才继续执行： 确保某个计算在其需要的所有资源都被初始化之后才继续执行; 确保某个服务在其依赖的所有其他服务都已经启动之后才启动; 等待直到某个操作所有参与者都准备就绪再继续执行 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-03 18:30:58 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/juc/5_Callable.html":{"url":"Chapter1/juc/5_Callable.html","title":"Callable","keywords":"","body":"CallableCallable Java 5.0 在java.util.concurrent 提供了一个新的创建执行线程的方式：Callable 接口 Callable 接口类似于Runnable，两者都是为那些其实例可能被另一个线程执行的类设计的。但是Runnable 不会返回结果，并且无法抛出经过检查的异常。 Callable 需要依赖FutureTask ，FutureTask 也可以用作闭锁 /* * 一、创建执行线程的方式三：实现 Callable 接口。 相较于实现 Runnable 接口的方式，方法可以有返回值，并且可以抛出异常。 * * 二、执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。 FutureTask 是 Future 接口的实现类 */ public class TestCallable { public static void main(String[] args) { ThreadDemo td = new ThreadDemo(); //1.执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。 FutureTask result = new FutureTask<>(td); new Thread(result).start(); //2.接收线程运算后的结果 try { Integer sum = result.get(); //FutureTask 可用于 闭锁 System.out.println(sum); System.out.println(\"------------------------------------\"); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } } } class ThreadDemo implements Callable{ @Override public Integer call() throws Exception { int sum = 0; for (int i = 0; i Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-06 09:37:18 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/juc/6_Lock.html":{"url":"Chapter1/juc/6_Lock.html","title":"Lock","keywords":"","body":"Lock 显式锁Lock 显式锁 在 Java 5.0 之前，协调共享对象的访问时可以使用的机制只有 synchronized 和 volatile 。Java 5.0 后增加了一些新的机制，但并不是一种替代内置锁的方法，而是当内置锁不适用时，作为一种可选择的高级功能。 ReentrantLock 实现了 Lock 接口，并提供了与synchronized 相同的互斥性和内存可见性。但相较于synchronized 提供了更高的处理锁的灵活性 public class TestLock { public static void main(String[] args) { Ticket ticket = new Ticket(); new Thread(ticket, \"1号窗口\").start(); new Thread(ticket, \"2号窗口\").start(); new Thread(ticket, \"3号窗口\").start(); } } class Ticket implements Runnable{ private int tick = 100; private Lock lock = new ReentrantLock(); @Override public void run() { while(true){ lock.lock(); //上锁 try{ if(tick > 0){ try { Thread.sleep(200); } catch (InterruptedException e) { } System.out.println(Thread.currentThread().getName() + \" 完成售票，余票为：\" + --tick); } }finally{ lock.unlock(); //释放锁 } } } } Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-06 10:09:26 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/juc/7_生产者消费者案例-虚假唤醒.html":{"url":"Chapter1/juc/7_生产者消费者案例-虚假唤醒.html","title":"生产者消费者案例","keywords":"","body":"生产者消费者案例-虚假唤醒正常的生产者消费者案例给生产者设置延时多个生产者消费者生产者消费者案例-虚假唤醒 正常的生产者消费者案例 我们测试的即是唤醒机制,如果没有等待和唤醒,则会出现生产了没有线程消费,消费完了,没有线程生产的现象,这种情况这里不进行验证,我们test wait()和notifyAll()的问题 //1 先定义一个售货员角色类 class Saler { private int product = 0;//产品数量 public synchronized void get() { //进货 if (product >= 5) { //5个为货满 System.out.println(\"产品已满\"); try { this.wait(); } catch (InterruptedException e) { } } else { System.out.println(Thread.currentThread().getName() + \" : \" + ++product); this.notifyAll(); } } public synchronized void sale() { //卖货 if (product 给生产者设置延时 run方法里添加200ms的延时,这时生产者会慢于消费者,货满仍然为1(为了明显显示效果) class Pro implements Runnable { private Saler saler; public Pro(Saler saler) { this.saler = saler; } @Override public void run() { for (int i = 0; i = 1) { System.out.println(\"产品已满\"); try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(Thread.currentThread().getName() + \" : \" + ++product); this.notifyAll(); } public synchronized void sale() {//product = 0; 循环次数：0 if (product 多个生产者消费者 能过以上的处理我们成功解决了上述问题但当存在多个生产者消费者是,会出现新的问题,我们继续分析一下 public class Test { public static void main(String[] args) { Saler saler = new Saler(); Pro pro = new Pro(saler); Con cus = new Con(saler); new Thread(pro, \"生产者 A\").start(); new Thread(cus, \"消费者 B\").start(); new Thread(pro, \"生产者 C\").start(); new Thread(cus, \"消费者 D\").start(); } } //结果如下 发现出现了负数 缺货 缺货 生产者 A : 1 消费者 B : 0 缺货 消费者 D : -1 缺货 生产者 C : 0 消费者 D : -1 缺货 消费者 B : -2 缺货 消费者 D : -3 缺货 消费者 B : -4 缺货 消费者 D : -5 缺货 消费者 B : -6 缺货 消费者 D : -7 缺货 消费者 B : -8 缺货 消费者 D : -9 缺货 消费者 B : -10 缺货 消费者 D : -11 缺货 消费者 B : -12 缺货 消费者 D : -13 缺货 消费者 B : -14 缺货 消费者 D : -15 缺货 消费者 B : -16 缺货 消费者 D : -17 消费者 B : -18 生产者 A : -17 生产者 C : -16 生产者 A : -15 生产者 C : -14 生产者 A : -13 生产者 C : -12 生产者 C : -11 生产者 A : -10 生产者 C : -9 生产者 A : -8 生产者 C : -7 生产者 A : -6 生产者 C : -5 生产者 A : -4 生产者 C : -3 生产者 A : -2 生产者 A : -1 生产者 C : 0 //原因分析 假设2个消费者同时抢占资源 //当1个消费者抢占锁后,发现product==0,则wait()并释放锁, 此时另一个消费者抢占资源,发现product==0,也wait()并释放锁 //此时当生产者执行notifyAll()后, 同时唤醒2个消费者,都执行--product操作,即产生负数情况 //这就叫做虚假唤醒 //解决方案,将if替换为while, 被唤醒后重新判断product值(jdk api中有说明) class Saler { private int product = 0; public synchronized void get() {//循环次数：0 while (product >= 1) { System.out.println(\"产品已满\"); try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(Thread.currentThread().getName() + \" : \" + ++product); this.notifyAll(); } public synchronized void sale() {//product = 0; 循环次数：0 while (product Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-06 13:08:48 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/juc/8_Condition.html":{"url":"Chapter1/juc/8_Condition.html","title":"Condition","keywords":"","body":"Condition 线程通信线程按序交替Condition 线程通信 Condition 接口描述了可能会与锁有关联的条件变量。这些变量在用法上与使用 Object.wait 访问的隐式监视器类似，但提供了更强大的功能。需要特别指出的是，单个 Lock 可能与多个 Condition 对象关联。为了避免兼容性问题，Condition 方法的名称与对应的 Object 版本中的不同。 在 Condition 对象中，与 wait、notify 和 notifyAll 方法对应的分别是await、signal 和 signalAll。 Condition 实例实质上被绑定到一个锁上。要为特定 Lock 实例获得Condition 实例，请使用其 newCondition() 方法 //使用区别如下 class Clerk2 { private int product = 0; private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); // 进货 public void get() { lock.lock(); try { while (product >= 1) { // 为了避免虚假唤醒，应该总是使用在循环中。 System.out.println(\"产品已满！\"); try { condition.await(); } catch (InterruptedException e) { } } System.out.println(Thread.currentThread().getName() + \" : \" + ++product); condition.signalAll(); } finally { lock.unlock(); } } // 卖货 public void sale() { lock.lock(); try { while (product 线程按序交替 编写一个程序，开启 3 个线程，这三个线程的 ID 分别为 A、B、C，每个线程将自己的 ID 在屏幕上打印 10 遍，要求输出的结果必须按顺序显示如：ABCABCABC…… 依次递归 public class TestABCAlternate { public static void main(String[] args) { AlternateDemo ad = new AlternateDemo(); new Thread(new Runnable() { @Override public void run() { for (int i = 1; i Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-06 13:24:38 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/juc/9_ReadWriteLock.html":{"url":"Chapter1/juc/9_ReadWriteLock.html","title":"ReadWriteLock","keywords":"","body":"ReadWriteLock 读写锁ReadWriteLock 读写锁 ReadWriteLock 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 writer，读取锁可以由多个 reader 线程同时保持。写入锁是独占的。。 ReadWriteLock 读取操作通常不会改变共享资源，但执行写入操作时，必须独占方式来获取锁。对于读取操作占多数的数据结构。 ReadWriteLock 能提供比独占锁更高的并发性。而对于只读的数据结构，其中包含的不变性可以完全不需要考虑加锁操作 读写/写写 互斥 读读不互斥 public class TestReadWriteLock { public static void main(String[] args) { ReadWriteLockDemo rw = new ReadWriteLockDemo(); new Thread(new Runnable() { @Override public void run() { rw.set((int) (Math.random() * 101)); } }, \"Write\").start(); for (int i = 0; i Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-06 13:37:55 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/juc/10_线程8锁.html":{"url":"Chapter1/juc/10_线程8锁.html","title":"线程8锁","keywords":"","body":"线程8锁线程8锁 一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调其中的一个synchronized方法了，其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized方法 锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法 加个普通方法后发现和同步锁无关 换成两个对象后，不是同一把锁了，情况立刻变化。 都换成静态同步方法后，情况又变化 所有的非静态同步方法用的都是同一把锁——实例对象本身，也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。 所有的静态同步方法用的也是同一把锁——类对象本身，这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象 /* * 题目：判断打印的 \"one\" or \"two\" ？ * * 1. 两个普通同步方法，两个线程，标准打印， 打印? //one two * 2. 新增 Thread.sleep() 给 getOne() ,打印? //one two * 3. 新增普通方法 getThree() , 打印? //three one two * 4. 两个普通同步方法，两个 Number 对象，打印? //two one * 5. 修改 getOne() 为静态同步方法，打印? //two one * 6. 修改两个方法均为静态同步方法，一个 Number 对象? //one two * 7. 一个静态同步方法，一个非静态同步方法，两个 Number 对象? //two one * 8. 两个静态同步方法，两个 Number 对象? //one two * * 线程八锁的关键： * ①非静态方法的锁默认为 this, 静态方法的锁为 对应的 Class 实例 * ②某一个时刻内，只能有一个线程持有锁，无论几个方法。 */ public class TestThread8Monitor { public static void main(String[] args) { Number number = new Number(); Number number2 = new Number(); new Thread(new Runnable() { @Override public void run() { number.getOne(); } }).start(); new Thread(new Runnable() { @Override public void run() { // number.getTwo(); number2.getTwo(); } }).start(); /*new Thread(new Runnable() { @Override public void run() { number.getThree(); } }).start();*/ } } class Number { public static synchronized void getOne() {//Number.class try { Thread.sleep(3000); } catch (InterruptedException e) { } System.out.println(\"one\"); } public synchronized void getTwo() {//this System.out.println(\"two\"); } public void getThree() { System.out.println(\"three\"); } } Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-06 13:43:19 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/juc/11_线程池.html":{"url":"Chapter1/juc/11_线程池.html","title":"线程池","keywords":"","body":"线程池线程调度线程池 第四种获取线程的方法：线程池，一个 ExecutorService，它使用可能的几个池线程之一执行每个提交的任务，通常使用 Executors 工厂方法配置。 线程池可以解决两个不同问题：由于减少了每个任务调用的开销，它们通常可以在执行大量异步任务时提供增强的性能，并且还可以提供绑定和管理资源（包括执行任务集时使用的线程）的方法。每个 ThreadPoolExecutor 还维护着一些基本的统计数据，如完成的任务数。 为了便于跨大量上下文使用，此类提供了很多可调整的参数和扩展钩子 (hook)。但是，强烈建议程序员使用较为方便的 Executors 工厂方法 ： Executors.newCachedThreadPool()（无界线程池，可以进行自动线程回收）Executors.newFixedThreadPool(int)（固定大小线程池）Executors.newSingleThreadExecutor()（单个后台线程） 它们均为大多数使用场景预定义了设置 /* * 一、线程池：提供了一个线程队列，队列中保存着所有等待状态的线程。避免了创建与销毁额外开销，提高了响应的速度。 * * 二、线程池的体系结构： * java.util.concurrent.Executor : 负责线程的使用与调度的根接口 * |--**ExecutorService 子接口: 线程池的主要接口 * |--ThreadPoolExecutor 线程池的实现类 * |--ScheduledExecutorService 子接口：负责线程的调度 * |--ScheduledThreadPoolExecutor ：继承 ThreadPoolExecutor， 实现 ScheduledExecutorService * * 三、工具类 : Executors * ExecutorService newFixedThreadPool() : 创建固定大小的线程池 * ExecutorService newCachedThreadPool() : 缓存线程池，线程池的数量不固定，可以根据需求自动的更改数量。 * ExecutorService newSingleThreadExecutor() : 创建单个线程池。线程池中只有一个线程 * * ScheduledExecutorService newScheduledThreadPool() : 创建固定大小的线程，可以延迟或定时的执行任务。 */ public class TestThreadPool { public static void main(String[] args) throws Exception { //1. 创建线程池 ExecutorService pool = Executors.newFixedThreadPool(5); List> list = new ArrayList<>(); for (int i = 0; i future = pool.submit(new Callable() { @Override public Integer call() throws Exception { int sum = 0; for (int i = 0; i future : list) { System.out.println(future.get()); } /*ThreadPoolDemo tpd = new ThreadPoolDemo(); //2. 为线程池中的线程分配任务 for (int i = 0; i 线程调度 一个 ExecutorService，可安排在给定的延迟后运行或定期执行的命令 public class TestScheduledThreadPool { public static void main(String[] args) throws Exception { ScheduledExecutorService pool = Executors.newScheduledThreadPool(5); for (int i = 0; i result = pool.schedule(new Callable() { @Override public Integer call() throws Exception { int num = new Random().nextInt(100);//生成随机数 System.out.println(Thread.currentThread().getName() + \" : \" + num); return num; } }, 1, TimeUnit.SECONDS); System.out.println(result.get()); } pool.shutdown(); } } Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-06 14:48:08 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/juc/12_ForkJoinPool.html":{"url":"Chapter1/juc/12_ForkJoinPool.html","title":"Fork/Join","keywords":"","body":"ForkJoinPool 分支合并框架 工作窃取Fork/Join与线程池的区别测试代码ForkJoinPool 分支合并框架 工作窃取 Fork/Join Fork/Join 框架：就是在必要的情况下，将一个大任务，进行拆分(fork)成若干个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行 join 汇总 与线程池的区别 采用 “工作窃取”模式（work-stealing）：当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。 相对于一般的线程池实现，fork/join框架的优势体现在对其中包含的任务的处理方式上.在一般的线程池中，如果一个线程正在执行的任务由于某些原因无法继续运行，那么该线程会处于等待状态。而在fork/join框架实现中，如果某个子问题由于等待另外一个子问题的完成而无法继续运行。那么处理该子问题的线程会主动寻找其他尚未运行的子问题来执行.这种方式减少了线程的等待时间，提高了性能 测试代码 public class TestForkJoinPool { public static void main(String[] args) { Instant start = Instant.now(); ForkJoinPool pool = new ForkJoinPool(); ForkJoinTask task = new ForkJoinSumCalculate(0L, 50000000000L); Long sum = pool.invoke(task); System.out.println(sum); Instant end = Instant.now(); System.out.println(\"耗费时间为：\" + Duration.between(start, end).toMillis()); } @Test public void test1() { Instant start = Instant.now(); long sum = 0L; for (long i = 0L; i { /** * */ private static final long serialVersionUID = -259195479995561737L; private long start; private long end; private static final long THURSHOLD = 10000L; //临界值 public ForkJoinSumCalculate(long start, long end) { this.start = start; this.end = end; } @Override protected Long compute() { long length = end - start; if (length Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-06 14:37:18 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter2/":{"url":"Chapter2/","title":"GO技术","keywords":"","body":"GO技术GO技术 go在2007年9月形成构想,并于2009年11月发布,发明人是Robert Griesemer,Rob Pike和Ken Thompson. Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-05-06 10:42:21 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter2/go语言环境配置.html":{"url":"Chapter2/go语言环境配置.html","title":"Go语言环境配置","keywords":"","body":"go语言环境配置go语言环境配置 1.使用brew安装最新稳定版本的go 1.13 brew search go ==> Formulae algol68g gnu-go gobuster google-java-format govendor pango anycable-go go gocr google-sparsehash gowsdl pangomm arangodb go-bindata gocryptfs google-sql-tool gox powerline-go argon2 go-jira godep googler gst-plugins-good protoc-gen-go aws-google-auth go-md2man goenv goolabs gx-go pygobject3 baidupcs-go go-statik gofabric8 goose hugo ✔ ringojs bogofilter go@1.10 goffice gopass jfrog-cli-go spaceinvaders-go cargo-c go@1.11 golang-migrate gor jpegoptim spigot cargo-completion go@1.12 gollum goreleaser katago svgo cargo-instruments go@1.13 golo goreman lego wego certigo go@1.9 gom gosu lgogdownloader wireguard-go brew install go@1.13 Updating Homebrew... ==> Downloading https://homebrew.bintray.com/bottles/go@1.13-1.13.10_1.catalina.bottle.tar.gz ==> Downloading from https://akamai.bintray.com/25/2584dae283ebba63091d06fa1fd15ee9d218b79a60f0c19ba38a7ef8b9e08fdc?__gda__=exp=1588738427~hmac=9ae05b9de1d ######################################################################## 100.0% ==> Pouring go@1.13-1.13.10_1.catalina.bottle.tar.gz ==> Caveats go@1.13 is keg-only, which means it was not symlinked into /usr/local, because this is an alternate version of another formula. If you need to have go@1.13 first in your PATH run: echo 'export PATH=\"/usr/local/opt/go@1.13/bin:$PATH\"' >> ~/.zshrc ==> Summary &#x1F37A; /usr/local/Cellar/go@1.13/1.13.10_1: 9,279 files, 414.5MB ==> `brew cleanup` has not been run in 30 days, running now... Removing: /Users/zhaojianqiang/Library/Caches/Homebrew/gcc--9.2.0_2.catalina.bottle.tar.gz... (84.8MB) Removing: /Users/zhaojianqiang/Library/Caches/Homebrew/gmp--6.1.2_2.catalina.bottle.1.tar.gz... (996.4KB) Removing: /Users/zhaojianqiang/Library/Caches/Homebrew/isl--0.21.catalina.bottle.tar.gz... (1.4MB) Removing: /Users/zhaojianqiang/Library/Caches/Homebrew/libmpc--1.1.0.catalina.bottle.tar.gz... (114.4KB) Removing: /Users/zhaojianqiang/Library/Caches/Homebrew/mpfr--4.0.2.catalina.bottle.tar.gz... (1.1MB) Removing: /Users/zhaojianqiang/Library/Caches/Homebrew/gradle--6.0.1.zip... (134.7MB) Removing: /Users/zhaojianqiang/Library/Logs/Homebrew/gmp... (64B) Removing: /Users/zhaojianqiang/Library/Logs/Homebrew/mpfr... (64B) Removing: /Users/zhaojianqiang/Library/Logs/Homebrew/gcc... (64B) Removing: /Users/zhaojianqiang/Library/Logs/Homebrew/gradle... (102B) Removing: /Users/zhaojianqiang/Library/Logs/Homebrew/isl... (64B) Removing: /Users/zhaojianqiang/Library/Logs/Homebrew/groovy... (64B) Removing: /Users/zhaojianqiang/Library/Logs/Homebrew/libmpc... (64B) Pruned 14 symbolic links and 1 directories from /usr/local 到这一步go即安装完成了 2.配置go go env GO111MODULE=\"\" GOARCH=\"amd64\" GOBIN=\"/Users/zhaojianqiang/Documents/code/go/bin\" GOCACHE=\"/Users/zhaojianqiang/Library/Caches/go-build\" GOENV=\"/Users/zhaojianqiang/Library/Application Support/go/env\" GOEXE=\"\" GOFLAGS=\"\" GOHOSTARCH=\"amd64\" GOHOSTOS=\"darwin\" GONOPROXY=\"\" GONOSUMDB=\"\" GOOS=\"darwin\" GOPATH=\"/Users/zhaojianqiang/Documents/code/go\" GOPRIVATE=\"\" GOPROXY=\"https://proxy.golang.org,direct\" GOROOT=\"/usr/local/opt/go@1.13/libexec\" GOSUMDB=\"sum.golang.org\" GOTMPDIR=\"\" GOTOOLDIR=\"/usr/local/opt/go@1.13/libexec/pkg/tool/darwin_amd64\" GCCGO=\"gccgo\" AR=\"ar\" CC=\"clang\" CXX=\"clang++\" CGO_ENABLED=\"1\" GOMOD=\"\" CGO_CFLAGS=\"-g -O2\" CGO_CPPFLAGS=\"\" CGO_CXXFLAGS=\"-g -O2\" CGO_FFLAGS=\"-g -O2\" CGO_LDFLAGS=\"-g -O2\" PKG_CONFIG=\"pkg-config\" GOGCCFLAGS=\"-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/1v/hmp36dtx5wlbpc2zpkk2w2h80000gp/T/go-build469326368=/tmp/go-build -gno-record-gcc-switches -fno-common\" 将GOROOT, GOPATH配置到.bash_profile中 vim .bash_profile #添加如下 注意GOPATH不要配置到go的安装目录下,可以自定义一个目录 #GOROOT： go安装目录 #GOPATH：go工作目录 #GOBIN：go可执行文件目录 #PATH：将go可执行文件加入PATH中，使GO命令与我们编写的GO应用可以全局调用 export GOROOT=/usr/local/opt/go\\@1.13 export GOPATH=/Users/zhaojianqiang/Documents/code/go export GOBIN=$GOPATH/bin export PATH=$PATH:$GOBIN:$GOROOT/bin #完成后保存并使之生效 source .bash_profile 再次使用go env查看, 即可看到刚才配置的信息到此go就完全安装完成了, 常用工具用GoLand, 开始你的go编程之路吧 3.linux配置 以上是mac os系统配置go, linux的go环境配置相当简单 # step1 下载包 wget https://dl.google.com/go/go1.14.4.linux-amd64.tar.gz # step2 解压 tar -C /usr/local -xzf go1.14.4.linux-amd64.tar.gz # step3 环境变量配置 在/etc/profile文件追加 export PATH=$PATH:/usr/local/go/bin # step4 测试安装 创建一个hello.go文件,包含以下代码 package main import \"fmt\" func main() { fmt.Printf(\"hello, world\\n\") } # 编译 go build hello.go # 运行,成功后输入hello, world ./hello Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-01 13:10:22 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter3/":{"url":"Chapter3/","title":"深入理解JVM","keywords":"","body":"深入理解JVM深入理解JVM Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2019-11-07 23:31:37 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter4/":{"url":"Chapter4/","title":"算法知识","keywords":"","body":"算法知识算法知识 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2019-11-07 23:31:37 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter5/":{"url":"Chapter5/","title":"SPRING系列","keywords":"","body":"SPRING系列SPRING系列 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2019-11-07 23:31:37 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter5/Spring.html":{"url":"Chapter5/Spring.html","title":"Spring","keywords":"","body":"SpringSpring Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2019-11-07 23:31:37 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter5/SpringBoot.html":{"url":"Chapter5/SpringBoot.html","title":"SpringBoot","keywords":"","body":"SpringBootSpringBoot Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2019-11-07 23:31:37 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter5/SpringCloud.html":{"url":"Chapter5/SpringCloud.html","title":"SpringCloud","keywords":"","body":"SpringCloudSpringCloud Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2019-11-07 23:31:37 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter6/":{"url":"Chapter6/","title":"DOCKER","keywords":"","body":"DOCKER简介优点组成DOCKER 简介 Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版） 优点 快速，一致地交付您的应用程序, 适用于ci/cd流程 响应式部署和扩展 在同一硬件上运行更多工作负载 组成 镜像(image):Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统 容器(container):镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等 仓库(repository):仓库可看成一个代码控制中心，用来保存镜像 概念 说明 Docker 镜像(Images) Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。 Docker 容器(Container) 容器是独立运行的一个或一组应用，是镜像运行时的实体。 Docker 客户端(Client) Docker 客户端通过命令行或者其他工具使用 Docker SDK (https://docs.docker.com/develop/sdk/) 与 Docker 的守护进程通信。 Docker 主机(Host) 一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。 Docker Registry Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(https://hub.docker.com) 提供了庞大的镜像集合供使用。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 : 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签 Docker Machine Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-01 16:17:13 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter6/CentOS8安装docker.html":{"url":"Chapter6/CentOS8安装docker.html","title":"Docker的安装","keywords":"","body":"CentOS8安装docker-ce安装安装校验CentOS8安装docker-ce Docker现在分为两个版本，Docker CE和Docker EE 其中Docker CE为开源版，Docker EE为企业版 安装 # step 1: 安装必要的一些系统工具 sudo yum install -y yum-utils device-mapper-persistent-data lvm2 # Step 2: 添加软件源信息 sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # Step 3: 更新并安装Docker-CE sudo yum makecache fast sudo yum -y install docker-ce # Step 3.1(非必要步骤): 安装containerd.io. centos8上因containerd.io版本过低, 在step3会报以下异常 上次元数据过期检查：0:03:35 前，执行于 2020年06月30日 星期二 17时31分14秒。 错误： 问题: package docker-ce-3:19.03.12-3.el7.x86_64 requires containerd.io >= 1.2.2-3, but none of the providers can be installed - cannot install the best candidate for the job - package containerd.io-1.2.10-3.2.el7.x86_64 is filtered out by modular filtering - package containerd.io-1.2.13-3.1.el7.x86_64 is filtered out by modular filtering - package containerd.io-1.2.13-3.2.el7.x86_64 is filtered out by modular filtering - package containerd.io-1.2.2-3.3.el7.x86_64 is filtered out by modular filtering - package containerd.io-1.2.2-3.el7.x86_64 is filtered out by modular filtering - package containerd.io-1.2.4-3.1.el7.x86_64 is filtered out by modular filtering - package containerd.io-1.2.5-3.1.el7.x86_64 is filtered out by modular filtering - package containerd.io-1.2.6-3.3.el7.x86_64 is filtered out by modular filtering (尝试添加 '--skip-broken' 来跳过无法安装的软件包 或 '--nobest' 来不只使用最佳选择的软件包) # 可以看到containerd.io >= 1.2.2-3, 但是centos8上没有高版本的containerd.io,这时需要我们手动去下载,完成以下步骤后再执行step3即可 wget https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/stable/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpm yum install ~/containerd.io-1.2.6-3.3.el7.x86_64.rpm # Step 4: 开启Docker服务 sudo service docker start # 注意： # 官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，您可以通过以下方式开启。同理可以开启各种测试版本等。 # vim /etc/yum.repos.d/docker-ee.repo # 将[docker-ce-test]下方的enabled=0修改为enabled=1 # # 安装指定版本的Docker-CE: # Step 1: 查找Docker-CE的版本: # yum list docker-ce.x86_64 --showduplicates | sort -r # Loading mirror speeds from cached hostfile # Loaded plugins: branch, fastestmirror, langpacks # docker-ce.x86_64 17.03.1.ce-1.el7.centos docker-ce-stable # docker-ce.x86_64 17.03.1.ce-1.el7.centos @docker-ce-stable # docker-ce.x86_64 17.03.0.ce-1.el7.centos docker-ce-stable # Available Packages # Step2: 安装指定版本的Docker-CE: (VERSION例如上面的17.03.0.ce.1-1.el7.centos) # sudo yum -y install docker-ce-[VERSION] 安装校验 docker version Client: Docker Engine - Community Version: 19.03.12 API version: 1.40 Go version: go1.13.10 Git commit: 48a66213fe Built: Mon Jun 22 15:46:54 2020 OS/Arch: linux/amd64 Experimental: false Server: Docker Engine - Community Engine: Version: 19.03.12 API version: 1.40 (minimum version 1.12) Go version: go1.13.10 Git commit: 48a66213fe Built: Mon Jun 22 15:45:28 2020 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.2.6 GitCommit: 894b81a4b802e4eb2a91d1ce216b8817763c29fb runc: Version: 1.0.0-rc8 GitCommit: 425e105d5a03fabd737a126ad93d62a9eeede87f docker-init: Version: 0.18.0 GitCommit: fec3683 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-03 13:38:39 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter6/镜像加速.html":{"url":"Chapter6/镜像加速.html","title":"镜像加速","keywords":"","body":"镜像加速镜像加速 以阿里云的centos为例,在阿里云的容器镜像服务中找到镜像加速链接以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-01 17:02:24 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter7/":{"url":"Chapter7/","title":"NETTY","keywords":"","body":"NETTYNETTY Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2019-11-07 23:31:37 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter8/":{"url":"Chapter8/","title":"Kafka","keywords":"","body":"KafkaKafka Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-02-18 17:14:41 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"}}
{"./":{"url":"./","title":"前言","keywords":"","body":"简介简介 ​ 该books站点为古道长亭的技术系列,喜欢的朋友可以收藏该站点或者博客站点,也可以关注博主的GitHub,以及CSDN,互相交流学习. ​ Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2019-11-07 23:31:37 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/":{"url":"Chapter1/","title":"JAVA技术","keywords":"","body":"JAVA技术JAVA技术 java基本语法结构,特性及面向对象略过...只列举java高级编程部分 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-14 11:27:40 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/exception/Exception.html":{"url":"Chapter1/exception/Exception.html","title":"异常","keywords":"","body":"异常分类Exception异常 Java语言中,程序执行中发生的不正常的情况 分类 Errorjava虚拟机无法解决的严重问题,如:系统内部错误,资源耗尽等,StackOverFlow和OOM(OutOfMemory) Exception因编程错误和外在因素导致的一般性问题,可以用针对性的代码进行处理,如空指针,试图读取的文件不存在,网络连接中断,数组下标越界等 Exception 编译时异常(checked) IOException FileNotFoundException ClassNotFoundException...... 运行时异常(unchecked) NullPointerExceptionArrayIndexOutOfBoundsExceptionClassCastExceptionNumberFormatExceptionInputMismatchExceptionArithmeticException...... 处理方法 try-catch-finallythrows Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-09 09:31:55 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/thread/":{"url":"Chapter1/thread/","title":"多线程","keywords":"","body":"多线程程序进程线程多线程的优点单核cpu和多核cpu并行与并发多线程 程序 是为完成特定任务、用某种语言编写的一组指令的集合.即指一段静态的代码,静态对象 进程 是程序的一次执行过程，或是正在运行的一个程序 。是一个动态的过程：有它自身的产生、存在和消亡的过程进程作为资源分配的单位,系统在运行时会为每个进程分配不同的内存区域 线程 进程可进一步细化为线程，是一个程序内部的一条执行路径。 若一个进程同一时间并行执行多个线程，就是支持多线程的 线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器 ( pc)，线程切换的开销小 一个进程中的多个线程共享相同的内存单元内存地址空间->它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患 多线程的优点 1.提高应用程序的响应。对图形化界面更有意义，可增强用户体验2.提高计算机系统 CPU 的利用率3.改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改何时使用: 程序需要同时执行多个任务 程序需要实现一些需要等待的任务时 需要一些后台运行的程序时 单核cpu和多核cpu 单核 CPU ，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费才能通过，那么 CPU 就好比收费人员。如果有某个人不想交钱， 那么收费 人员可以把他“挂起”（晾着他，等他想通了，准备好了钱，再去收费）.但是因为 CPU 时间单元特别短，因此感觉不出来。 如果是多核的话，才能更好的发挥多线程的效率。（现在的服务器都是多核的） 一个 Java 应用程序 java.exe ，其实至少有三个线程 main() 主线程， gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程 。 并行与并发 并行: 多个cpu同时执行多个任务. 并发: 一个cpu(采用时间切片)同时执行多个任务.比如:秒杀 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-13 09:31:28 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/thread/thread.html":{"url":"Chapter1/thread/thread.html","title":"线程创建","keywords":"","body":"线程线程创建继承Thread类实现Runnable接口区别实现Callable接口线程池线程调度线程的分类生命周期线程 线程创建 继承Thread类 Thread构造器 Tread() 创建新的Thread对象 Thread(String threadName) 创建线程并指定线程的实例名 Thread(Runnable target) 指定创建线程的目标对象，它实现了 Runnable 接口中的 run 方法 Thread(Runnable target, String name) 创建新的Thread对象 常用方法 void start(): 启动线程，并执行对象的 run() 方法 run(): 线程在被调度时执行的操作 String getName (): 返回线程的名称 void setName (String name) 设置该线程名称 static Thread currentThread (): 返回当前线程。在 Thread 子类中就是 this，通常用于主线程和 Runnable 实现类 static void yield() 线程让步 暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程若队列中没有同优先级的线程，忽略此方法 join() 当某个程序执行流中调用其他线程的 join() 方法时 调用线程 将被阻塞，直到 join() 方法加入的 join 线程执行完为止 低优先级的线程也可以获得执行 static void sleep(long millis 指定时间 毫秒 令当前活动线程在指定时间段内放弃对 CPU 控制 使其他线程有机会被执行 时间到后重排队抛出 InterruptedException 异常 stop(): 强制线程生命期结束，不推荐使用 boolean isAlive 返回 boolean ，判断线程是否还活着 class MyTread extends Thread { @Override public void run() { for (int i = 0; i 实现Runnable接口 class HelloThread implements Runnable{ @Override public void run() { System.out.println(\"hello thread\"); } } 区别 区别 继承 Thread ：线程代码存放 Thread 子类 run 方法中。 实现 Runnable ：线程代码存在接口的子类的 run 方法。 实现方式的好处 避免了单继承的局限性 多个线程可以共享同一个接口实现的对象，非常适合多个相同线程来处理同一份资源 实现Callable接口 参考juc 中的callable 线程池 参考juc 中的线程池 线程调度 调度策略 时间片 抢占式:高优先级的线程抢占cpu Java调度方法 同优先级线程组成先进先出队列,使用时间片策略 高优先级,使用优先调度的抢占策略 线程的优先级 MAX_PRIORITY 10 MIN PRIORITY 1 NORM_PRIORITY 5 方法 getPriority() 返回优先级 setPriority(int newPriority) 设置优先级 注意: 线程创建时继承父线程 的 优先级 低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用 线程的分类 Java中的线程分为两类：一种是 守护线程 ，一种是 用户线程 。 它们在几乎每个方面都是相同的，唯一的区别是判断 JVM 何时离开。 守护线程是用来服务用户线程的，通过在 start() 方法前调用thread.setDaemon (true) 可以把一个用户线程变成一个守护线程。 Java 垃圾回收就是一个典型的守护线程。 若 JVM 中都是守护线程，当前 JVM 将 退出 。 生命周期 JDK 中用 Thread State 类定义了线程的几种状态要想实现多线程,必须在主线程中创建新的线程对象.Java 语言使用 Thread 类及其子类的对象来表示线程,在它的一个完整的生命周期中通常要经历如下的 五种状态  新建： 当 一个 Thread 类或其子类的对象被声明并创建时，新生的线程对象处于新建状态 就绪： 处于 新建 状态的线程被 start() 后，将进入线程队列等待 CPU 时间片，此时它已具备了运行的条件，只是没分配到 CPU 资源 运行： 当就绪的线程被调度并获得 CPU 资源时便进入运行状态， run() 方法定义了线程的操作和功能 阻塞： 在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态 死亡： 线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-13 09:31:28 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/thread/thread_sync.html":{"url":"Chapter1/thread/thread_sync.html","title":"线程同步","keywords":"","body":"线程同步同步代码块同步方法Lock锁释放锁操作线程死锁线程同步 同步代码块 synchronized(同步监视器){ //需要被同步的代码 } 说明：1.操作共享数据的代码，即为需要被同步的代码。 -->不能包含代码多了，也不能包含代码少了。2.共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。3.同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。4.要求：多个线程必须要共用同一把锁。补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。 public class SyncTest1 { public static void main(String[] args) { Window1 w = new Window1(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(\"窗口1\"); t2.setName(\"窗口2\"); t3.setName(\"窗口3\"); t1.start(); t2.start(); t3.start(); } } //处理实现Runnable接口的纯种安全 class Window1 implements Runnable{ private int ticket = 100; @Override public void run() { while(true){ synchronized (this){ if (ticket > 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \":卖票，票号为：\" + ticket); ticket--; } else { break; } } } } } 同步方法 1.同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。2.非静态的同步方法，同步监视器是：this3.静态的同步方法，同步监视器是：当前类本身 public class SyncTest3 { public static void main(String[] args) { Window3 w = new Window3(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(\"窗口1\"); t2.setName(\"窗口2\"); t3.setName(\"窗口3\"); t1.start(); t2.start(); t3.start(); } } class Window3 implements Runnable { private int ticket = 100; @Override public void run() { while (true) { show(); } } private synchronized void show(){//同步监视器：this //synchronized (this){ if (ticket > 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \":卖票，票号为：\" + ticket); ticket--; } //} } } Lock锁 参考juc 中的Lock锁 释放锁操作 当前 线程的同步方法、同步代码块 执行结束。 当前 线程在同步代码块、同步方法中遇到 break 、 return 终止了该代码块、该方法的继续执行。 当前 线程在同步代码块、同步方法中出现了未处理的 Error 或 Exception 导致异常结束。 当前 线程在同步代码块、同步方法中执行了线程对象的 wait() 方法，当前线程暂停，并释放锁。 线程死锁 死锁 不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续 解决方法 专门的算法、原则尽量减少同步资源的定义尽量避免嵌套同步 public class DeadLockTest { public static void main(String[] args) { StringBuffer s1 = new StringBuffer(); StringBuffer s2 = new StringBuffer(); new Thread() { @Override public void run() { synchronized (s1) { s1.append(\"a\"); s2.append(\"1\"); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (s2) { s1.append(\"b\"); s2.append(\"2\"); System.out.println(s1); System.out.println(s2); } } } }.start(); new Thread(new Runnable() { @Override public void run() { synchronized (s2) { s1.append(\"c\"); s2.append(\"3\"); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (s1) { s1.append(\"d\"); s2.append(\"4\"); System.out.println(s1); System.out.println(s2); } } } }).start(); } } Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-13 09:31:28 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/thread/thread_post.html":{"url":"Chapter1/thread/thread_post.html","title":"线程通信","keywords":"","body":"线程通信生产者消费者案例线程通信 wait () 与 notify() 和 notifyAll wait()：令当前线程挂起并放弃CPU、同步资源并等待，使别的线程可访问并修改共享资源，而当前线程排队等候其他线程调用notify() 或 notifyAll() 方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行notify()：唤醒正在排队等待同步资源的线程中优先级最高者结束等待notifyAll()：唤醒正在排队等待资源的所有线程结束等待 这三个方法只有在 synchronized 方法或 synchronized 代码块中才能使用，否则会报java.lang.IllegalMonitorStateException 异常。 因为这三个方法必须有锁对象调用，而任意对象都可以作为 synchronized 的同步锁，因此这三个方法只能在 Object 类中声明 class Number implements Runnable{ private int number = 1; private Object obj = new Object(); @Override public void run() { while(true){ synchronized (obj) { obj.notify(); if(number 生产者消费者案例 class Clerk{ private int productCount = 0; //生产产品 public synchronized void produceProduct() { if(productCount 0){ System.out.println(Thread.currentThread().getName() + \":开始消费第\" + productCount + \"个产品\"); productCount--; notify(); }else{ //等待 try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } } class Producer extends Thread{//生产者 private Clerk clerk; public Producer(Clerk clerk) { this.clerk = clerk; } @Override public void run() { System.out.println(getName() + \":开始生产产品.....\"); while(true){ try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } clerk.produceProduct(); } } } class Consumer extends Thread{//消费者 private Clerk clerk; public Consumer(Clerk clerk) { this.clerk = clerk; } @Override public void run() { System.out.println(getName() + \":开始消费产品.....\"); while(true){ try { Thread.sleep(20); } catch (InterruptedException e) { e.printStackTrace(); } clerk.consumeProduct(); } } } public class ProductTest { public static void main(String[] args) { Clerk clerk = new Clerk(); Producer p1 = new Producer(clerk); p1.setName(\"生产者1\"); Consumer c1 = new Consumer(clerk); c1.setName(\"消费者1\"); Consumer c2 = new Consumer(clerk); c2.setName(\"消费者2\"); p1.start(); c1.start(); c2.start(); } } Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-13 09:31:28 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/common_class/":{"url":"Chapter1/common_class/","title":"常用类","keywords":"","body":"常用类常用类 String System Math BigInteger BigDecimal Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-09 09:31:55 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/common_class/String.html":{"url":"Chapter1/common_class/String.html","title":"String","keywords":"","body":"String实例化方式常用方法StringBuffer常用方法StringBuilder常用方法常见算法String 字符串,是一个final类,不可变字符序列,字符内容存储在一个字符数组value[]中 不可变性 char[]存储 实例化方式 字面量 构造器new 常用方法 ...略过 StringBuffer 可变 线程安全,效率低 char[]存储 默认capacity为16,不够时会继续扩容,默认扩容为capacity 常用方法 ...略过 StringBuilder 可变 线程不安全,效率高 jdk5.0新增 char[]存储 常用方法 ...略过 建议: 使用 StringBuffer(int capacity) 或 StringBuilder(int capacity) 常见算法 将一个字符串进行反转。将字符串中指定部分进行反转。比如“abcdefg”反转为”abfedcg” public class StringDemo { //方式一：转换为char[] public String reverse(String str, int startIndex, int endIndex) { if (str != null) { char[] arr = str.toCharArray(); for (int x = startIndex, y = endIndex; x = startIndex; i--) { reverseStr += str.charAt(i); } //第3部分 reverseStr += str.substring(endIndex + 1); return reverseStr; } return null; } //方式三：使用StringBuffer/StringBuilder替换String public String reverse2(String str, int startIndex, int endIndex) { if (str != null) { StringBuilder builder = new StringBuilder(str.length()); //第1部分 builder.append(str.substring(0, startIndex)); //第2部分 for (int i = endIndex; i >= startIndex; i--) { builder.append(str.charAt(i)); } //第3部分 builder.append(str.substring(endIndex + 1)); return builder.toString(); } return null; } @Test public void testReverse() { String str = \"abcdefg\"; String reverse = reverse1(str, 2, 5); System.out.println(reverse); } } 获取一个字符串在另一个字符串中出现的次数。比如：获取“ab”在 “abkkcadkabkebfkaabkskab” 中出现的次数 public class StringDemo { /** * 获取subStr在mainStr中出现的次数 */ public int getCount(String mainStr, String subStr) { int mainLength = mainStr.length(); int subLength = subStr.length(); int count = 0; int index = 0; if (mainLength >= subLength) { //方式一： // while((index = mainStr.indexOf(subStr)) != -1){ // count++; // mainStr = mainStr.substring(index + subStr.length()); // } //方式二：对方式一的改进 while ((index = mainStr.indexOf(subStr, index)) != -1) { count++; index += subLength; } return count; } else { return 0; } } @Test public void testGetCount() { String mainStr = \"abkkcadkabkebfkaabkskab\"; String subStr = \"ab\"; int count = getCount(mainStr, subStr); System.out.println(count); } } 获取两个字符串中最大相同子串。比如：str1 = \"abcwerthelloyuiodefabcdef\";str2 = \"cvhellobnm\" 提示：将短的那个串进行长度依次递减的子串与较长的串比较。 public class StringDemo2 { //前提：两个字符串中只有一个最大相同子串 public String getMaxSameString(String str1, String str2) { if (str1 != null && str2 != null) { String maxStr = (str1.length() >= str2.length()) ? str1 : str2; String minStr = (str1.length() str2.length()) ? str1 : str2; String minString = (str1.length() > str2.length()) ? str2 : str1; int len = minString.length(); for (int i = 0; i Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-09 09:31:55 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/common_class/System.html":{"url":"Chapter1/common_class/System.html","title":"System","keywords":"","body":"SystemgetProperty(String key)System 代表系统,系统级的很多属性和方都放置在此内部 构造器是private,成员变量和方法是static 成员变量 in, out , err 成员方法 currentTimeMillis(), exit, gc, getProperty(String key) getProperty(String key) 属性名 属性说明 java.version java运行时环境版本 java.home java安装目录 os.name 操作系统名称 os.version 操作系统版本 user.name 用户账户名称 user.home 用户的目录 user.dir 用户的当前工作目录 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-09 09:31:55 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/common_class/Math.html":{"url":"Chapter1/common_class/Math.html","title":"Math","keywords":"","body":"MathMath abs 绝对值 acos,asin,atan,cos,sin,tan 三角函数 sqrt 平方根 pow(double a,doble b) a的 b 次幂 log 自然对数 exp e为底指数 max(double a,double b) min(double a,double b) random() 返回 0.0 到 1.0 的随机数 long round(double a) double型数据 a 转换为long 型（四舍五入） toDegrees(double angrad) 弧度 角度 toRadians(double angdeg) 角度 弧度 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-09 09:31:55 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/common_class/BigInteger.html":{"url":"Chapter1/common_class/BigInteger.html","title":"BigInteger","keywords":"","body":"BigIntegerBigInteger java.math 包的 BigInteger 可以表示不可变的任意精度的整数 。 BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。 另外， BigInteger 还提供以下运算：模算术、 GCD 计算、质数测试、素数生成、位操作以及一些其他操作。 构造器 BigInteger(String val) 常用 方法 public BigInteger abs ()()：返回此 BigInteger 的绝对值的 BigInteger 。BigInteger add (BigInteger val) ：返回其值为 (this + val) 的 BigIntegerBigInteger subtract (BigInteger val) ：返回其值为 (this val) 的 BigIntegerBigInteger multiply (BigInteger val) ：返回其值为 (this * val) 的 BigIntegerBigInteger divide (BigInteger val) ：返回其值为 (this/val) 的 BigInteger 整数相除只保留整数部分BigInteger remainder (BigInteger val) ：返回其值为 (this % val) 的 BigIntegerBigInteger [] divideAndRemainder (BigInteger val)：返回包含 (this / val) 后跟(this % val) 的两个 BigInteger 的数组BigInteger pow (int exponent) ：返回其值为 (this exponent ) 的 BigInteger Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-09 09:31:55 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/common_class/BigDecimal.html":{"url":"Chapter1/common_class/BigDecimal.html","title":"BigDecimal","keywords":"","body":"BigDecimalBigDecimal 一般的 Float 类和 Double 类可以用来做科学计算或工程计算，但在 商业计算中，要求数字精度比较高，故用到 java.math.BigDecimal 类 BigDecimal 类支持不可变的、任意精度的有符号十进制定点数 构造器 public BigDecimal(double val)public BigDecimal (String val) 常用方法 public BigDecimal add (BigDecimal)public BigDecimal subtract (BigDecimal)public BigDecimal multiply (BigDecimal)public BigDecimal divide (BigDecimal divisor, int scale, int roundingMode) Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-09 09:31:55 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/enum_annotation/":{"url":"Chapter1/enum_annotation/","title":"枚举和注解","keywords":"","body":"枚举类和注解枚举类和注解 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-09 09:31:55 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/enum_annotation/enum.html":{"url":"Chapter1/enum_annotation/enum.html","title":"枚举","keywords":"","body":"Enum例常用方法实现接口Enum 私有化构造器 private final实例变量 实例以','分隔, 以';'结尾 必肱在第1行声明枚举类对象 例 public enum SeasonEnum { SPRING(\"春天\", \"春风又绿江南岸\"), SUMMER(\"夏天\", \"映日荷花别样红\"), AUTUMN(\"秋天\", \"秋水共长天一色\"), WINTER(\"冬天\", \"窗含西岭千秋雪\"); private final String seasonName; private final String seasonDesc; private SeasonEnum(String seasonName, String seasonDesc) { this.seasonName = seasonName; this.seasonDesc = seasonDesc; } public String getSeasonName() { return seasonName; } public String getSeasonDesc() { return seasonDesc; } } 常用方法 values() 方法 ：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。 valueOf (String str ))：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有 运行 时异常：IllegalArgumentException 。 toString()toString()：返回当前枚举类对象常量的名称 public class EnumTest { @Test public void t3() { SeasonEnum spring = SeasonEnum.valueOf(\"SPRING\"); System.out.println(spring); } @Test public void t2() { SeasonEnum[] values = SeasonEnum.values(); Arrays.asList(values).forEach(System.out::println); System.out.println(\"------------------------------------\"); //线程状态 Thread.State[] values1 = Thread.State.values(); Arrays.asList(values1).forEach(System.out::println); } @Test public void t1() { SeasonEnum s1 = SeasonEnum.SPRING; System.out.println(s1.getSeasonName()); System.out.println(s1.getSeasonDesc()); System.out.println(s1); System.out.println(s1.toString()); System.out.println(SeasonEnum.class.getSuperclass()); } } 实现接口 和普通 Java 类一样，枚举类可以实现一个或多个接口 若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。 若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式,则可以让每个枚举值分别来实现该方法 public interface EnumShow { public void show(); } public enum SeasonEnum implements EnumShow { SPRING(\"春天\", \"春风又绿江南岸\"){ @Override public void show() { //do something } }, SUMMER(\"夏天\", \"映日荷花别样红\") { @Override public void show() { //do something } }, AUTUMN(\"秋天\", \"秋水共长天一色\") { @Override public void show() { //do something } }, WINTER(\"冬天\", \"窗含西岭千秋雪\") { @Override public void show() { //do something } }; private final String seasonName; private final String seasonDesc; private SeasonEnum(String seasonName, String seasonDesc) { this.seasonName = seasonName; this.seasonDesc = seasonDesc; } public String getSeasonName() { return seasonName; } public String getSeasonDesc() { return seasonDesc; } // @Override // public void show() { // System.out.println(\"四季\"); // } } Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-09 09:31:55 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/enum_annotation/annotation.html":{"url":"Chapter1/enum_annotation/annotation.html","title":"注解","keywords":"","body":"Annotation概述示例文档相关编译时进行格式检查(3个内置基本注解)跟踪代码依赖性,实现替代配置文件功能自定义注解元注解反射获取可重复注解与类型注解Annotation 概述 从 JDK 5.0 开始 , Java增加了对元数据 (MetaData ) 的支持 , 也就是Annotation( 注解) Annotation 其实就是代码里的 特殊标记 , 这些标记可以在编译,类加载,运行时被读取,并执行相应的处理。通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下,在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证 或者进行部署。 Annotation 可以像修饰符一样被使用,可用于修饰包类,构造器,方法,成员变量,参数,局部变量的声明,这些信息被保存在 Annotation的 “name=value” 对中 在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 JavaEE/Android 中注解占据了更重要的角色，例如:用来配置应用程序的任何切面， 代替 JavaEE 旧版中所遗留的繁冗代码和 XML 未来的开发模式都是基于注解的，一定程度上可以说： 框架 = 注解 + 反射 + 设计模式。 使用 Annotation 时要在其前面增加 @ 符号 , 并 把该 Annotation 当成一个修饰符使用。 用于修饰它支持的程序元素 示例 文档相关 @author 标明开发该类模块的作者 多个作者之间使用 分割 @version 标明该类模块的版本 @see 参考转向 也就是相关主题 @since 从哪个版本开始增加的 @param 对方法中某参数的说明 如果没有参数就不能写 @return 对方法返回值的说明 如果方法的返回值类型是 void 就不能写 @exception 对方法可能抛出的异常进行说明 如果方法没有用 throws 显式抛出的异常就不能写其中 @param @return 和 @exception 这三个标记都是只用于方法的 @param 的格式要求：@param 形参名 形参类型 形参说明 @return 的格式要求：@return 返回值类型 返回值说明 @exception 的格式要求：@exception 异常类型 异常说明 @param 和 @exception 可以并列多个 编译时进行格式检查(3个内置基本注解) @Override @Deprecated 用于表示所修饰的元素类,方法等已过时。通常是因为所修饰的结构危险或存在更好的选择 @SuppressWarnings 抑制编译器警告 跟踪代码依赖性,实现替代配置文件功能 servlet的@webServlet 或spring的@requestMapping 代替xml文件配置 自定义注解 定义新的 Annotation 类型使用 @interface 关键字 自定义注解自动继承了 java lang annotation Annotation 接口 Annotation 的成员变量在 Annotation 定义中以无参数方法的形式来 声明。其方法名和返回值定义了该成员的名字和类型。我们称为配置参数。类型只能是八种基本数据类型 、 String 类型 、 Class 类型 、 enum 类型 、 Annotation 类型 、以上所有类型的 数组 。 可以在定义 Annotation 的成员变量时为其指定初始值 指定成员变量的初始值可使用 default 关键字 如果只有一个参数成员 建议使用 参数名为 value 如果定义的注解含有配置参数 那么使用时必须指定参数值 除非它有默认值。格式是 参数名 参数值 如果只有一个参数成员 且名称为 value可以省略 value= 没有成员定义的 Annotation 称为 标记 包含成员变量的 Annotation 称为元数据 Annotation 注意：自定义注解必须配上注解的信息处理流程才有意义 @interface MyAnnotation { String value(); } 元注解 @Retention : 只能用于修饰一个 Annotation 定义,用于指定该Annotation的生命周期,Rentention包含一个 RetentionPolicy 类型的成员变量,使用Rentention 时必须为该 value 成员变量指定值 RetentionPolicy.SOURCE 在源文件中有效（即源文件保留) 编译器 直接丢弃这种策略的注释)RetentionPolicy.CLASS 在 class 文件中有效（即 class 保留）当运行 Java 程序时,JVM不会保留注解。这是默认值RetentionPolicy.RUNTIME 在运行时有效（即运行时保留) 当运行 Java 程序时 , JVM 会保留注释。程序 可以通过反射获取 该注释 @Target : 用于修饰 Annotation 定义 , 用于指定被修饰的 Annotation 能用于修饰哪些程序元素。 @Target 也包含一个名为 value 的 TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE @Documented: 用于指定被该元 Annotation 修饰的 Annotation 类将被javadoc 工具提取成文档。默认情况下 javadoc 是不包括注解的.定义为 Documented 的注解必须设置 Retention 值为 RUNTIME @Inherited: 被它修饰的 Annotation 将具有继承性。如果某个类使用了被@Inherited 修饰的 Annotation, 则其子类将自动具有该注解。比如：如果 把标有 @Inherited 注解的自定义的注解标注在类级别上子类则可以 继承父类类级别的注解,实际应用中，使用较少 反射获取 @Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE}) @Retention(RetentionPolicy.RUNTIME) @interface MyAnnotation { String value() default \"hello\"; } @MyAnnotation(\"Person\") public class Person { } public class AnnotationTest { //反射获取 @Test public void t1(){ Class clazz = Person.class; Annotation[] annotations = clazz.getAnnotations(); Arrays.asList(annotations).forEach(System.out::println); //获取值 MyAnnotation[] annotationsByType = clazz.getAnnotationsByType(MyAnnotation.class); for (MyAnnotation m : annotationsByType) { System.out.println(m.value()); } } } 可重复注解与类型注解 1.8新特性 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-09 09:31:55 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/collection/":{"url":"Chapter1/collection/","title":"集合","keywords":"","body":"集合CollectionMap集合 Collection List Set Map Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-13 09:31:28 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/collection/collection.html":{"url":"Chapter1/collection/collection.html","title":"Collection","keywords":"","body":"Collection常用方法Iterator遍历遍历移除 remove()foreach() 增强for循环CollectionsCollection 常用方法 add() addAll() int size() void clear() boolean isEmpty() boolean contains(Object obj) --通过equals方法判断 boolean containsAll(Collection c) --通过equals方法判断 boolean remove(Object obj) --通过equals方法判断并删除找到的第一个 boolean removeAll(Collection c) --取差集 boolean retainAll(Collection c) --取交集 boolean equals(Object obj) --集合是否相等 Object[] toAarray() --转成对象数据 hashCode() --获取hash值 iterator() --遍历 Iterator遍历 Iterator 对象称为迭代器 设计模式的一种 ))，主要用于遍历 Collection 集合中的元素 GOF 给迭代器模式的定义为：提供一种方法访问一个容器 ( 对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。类似于“公交车上的售票员”、“火车上的乘务员”、 “空姐 Collection 接口继承了 java.lang.Iterable 接口，该接口有一个 iterator() 方法，那么所有实现了 Collection 接口的集合类都有一个 iterator() 方法，用以返回一个实现了Iterator 接口的对象 Iterator 仅用于遍历集合 Iterator 本身并不提供承装对象的能力。如果需要 创建Iterator 对象，则必须有一个被迭代的集合 集合对象每次调用 iterator() 方法都得到一个全新的迭代器对象 ，默认游标都在集合的第一个元素之前 遍历 public class CollectionTest { @Test public void t2(){ //错误写法 Collection collection = new ArrayList(); collection.add(123); collection.add(\"abc\"); collection.add(false); collection.add(456); //错误1 Iterator iterator = collection.iterator(); while (iterator.next() != null){ System.out.println(iterator.next()); } //错误2: 每次iterator都是一个新的Iterator迭代器 while (collection.iterator().hasNext()){ System.out.println(collection.iterator().next()); } } @Test public void t1(){ Collection collection = new ArrayList(); collection.add(123); collection.add(\"abc\"); collection.add(false); collection.add(456); Iterator iterator = collection.iterator(); // System.out.println(iterator.next()); // System.out.println(iterator.next()); // System.out.println(iterator.next()); // System.out.println(iterator.next()); while (iterator.hasNext()){ System.out.println(iterator.next()); } } } 移除 remove() Iterator 可以删除集合的元素 但是是遍历过程中通过迭代器对象的 remove 方法 不是集合对象的 remove 方法 。 如果还未调用 next() 或在上一次调用 next 方法之后已经调用了 remove 方法再调用 remove 都会报 IllegalStateException public class CollectionTest2 { @Test public void t1(){ Collection collection = new ArrayList(); collection.add(123); collection.add(\"abc\"); collection.add(false); collection.add(456); Iterator iterator = collection.iterator(); while (iterator.hasNext()){ Object next = iterator.next(); if(next.equals(123)){ iterator.remove(); } } Iterator iterator2 = collection.iterator(); while (iterator2.hasNext()){ System.out.println(iterator2.next()); } } } foreach() 增强for循环 5.0新增, 底层调用iterator() Collections 操作Collection、Map的工具类1.操作排序 reverse(List)：反转 List 中元素的顺序 shuffle(List)：对 List 集合元素进行随机排序 sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序 sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序 swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换 2.查找,替换 Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素 Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素 Object min(Collection) Object min(Collection，Comparator) int frequency(Collection，Object)：返回指定集合中指定元素的出现次数 void copy(List dest,List src)：将src中的内容复制到dest中 boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值 3.同步控制Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题 List list = Collections.synchronizedList(list); Map map = Collections.synchronizedMap(list); ... public class CollectionsTest { @Test public void test2(){ List list = new ArrayList(); list.add(123); list.add(43); list.add(765); list.add(-97); list.add(0); //报异常：IndexOutOfBoundsException(\"Source does not fit in dest\") // List dest = new ArrayList(); // Collections.copy(dest,list); //正确的： List dest = Arrays.asList(new Object[list.size()]); System.out.println(dest.size());//list.size(); Collections.copy(dest,list); System.out.println(dest); /* Collections 类中提供了多个 synchronizedXxx() 方法， 该方法可使将指定集合包装成线程同步的集合，从而可以解决 多线程并发访问集合时的线程安全问题 */ //返回的list1即为线程安全的List List list1 = Collections.synchronizedList(list); } @Test public void test1(){ List list = new ArrayList(); list.add(123); list.add(43); list.add(765); list.add(765); list.add(765); list.add(-97); list.add(0); System.out.println(list); // Collections.reverse(list); // Collections.shuffle(list); // Collections.sort(list); // Collections.swap(list,1,2); int frequency = Collections.frequency(list, 123); System.out.println(list); System.out.println(frequency); } } Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-13 09:31:28 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/collection/collection_List.html":{"url":"Chapter1/collection/collection_List.html","title":"List","keywords":"","body":"ListArrayListLinkedListVectorArrayList 、 LinkedList 和 Vector之间的异同List 鉴于 Java 中数组用来存储数据 的局限性，我们通常使用 List 替代数组 List 集合类中 元素有序、且可重复 ，集合中的每个元素都有其对应的顺序索引。 List 容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。 JDK API 中 List 接口的实现类常用的有： ArrayList 、 LinkedList 和 Vector 常用方法 void add(int index, Object ele) 在 index 位置插入 ele 元素boolean addAll (int index, Collection) eles 从 index 位置开始将 eles 中的所有元素添加进来Object get( int index): 获取指定 index 位置的元素int indexOf (Object obj) 返回 obj 在集合中首次出现的位置int lastIndexOf (Object obj 返回 obj 在当前集合中末次出现的位置Object remove( int index): 移除指定 index 位置的元素，并返回此元素Object set( int index, Object ele) 设置指定 index 位置的元素为 eleList subList int fromIndex , int toIndex) 返回从 fromIndex 到 toIndex 位置的子集合 ArrayList ArrayList的源码分析： jdk 7情况下 ArrayList list = new ArrayList();//底层创建了长度是10的Object[]数组elementData list.add(123);//elementData[0] = new Integer(123); ... list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容。 默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。 结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity) jdk 8中ArrayList的变化： ArrayList list = new ArrayList();//底层Object[] elementData初始化为{}.并没有创建长度为10的数组 list.add(123);//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0] ... 后续的添加和扩容操作与jdk 7 无异。 小结：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存 LinkedList LinkedList的源码分析： LinkedList list = new LinkedList(); 内部声明了Node类型的first和last属性，默认值为null list.add(123);//将123封装到Node中，创建了Node对象。 其中，Node定义为：体现了LinkedList的双向链表的说法 private static class Node { E item; Node next; Node prev; Node(Node prev, E element, Node next) { this.item = element; this.next = next; this.prev = prev; } } Vector jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。在扩容方面，默认扩容为原来的数组长度的2倍 ArrayList 、 LinkedList 和 Vector之间的异同 ArrayList 和 LinkedList 的 异同二者都线程不安全，相对线程安全的Vector ，执行效率高。此外，ArrayList 是实现了基于动态数组的数据结构， LinkedList 基于链表的数据结构。对于随机访问 get 和 set ArrayList 觉得优于 LinkedList ，因为 LinkedList 要移动指针。对于新增 和删除 操作 add( 特指 插入 和 remove LinkedList 比较占优势，因为 ArrayList 要移动数据。 ArrayList 和 Vector 的区别Vector和 ArrayList 几乎是完全相同的 唯一的区别在于 Vector 是同步类 ( synchronized)，属于强同步类。因此开销就比 ArrayList 要大，访问要慢。正常情况下 大多数的 Java 程序员使用ArrayList 而不是 Vector, 因为同步完全可以由程序员自己来控制。 Vector 每次扩容请求其大 小的 2 倍空间，而 ArrayList 是 1.5 倍。 Vector 还有一个子 类 Stack Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-13 09:31:28 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/collection/collection_Set.html":{"url":"Chapter1/collection/collection_Set.html","title":"Set","keywords":"","body":"SetHashSetLinkedHashSet extends HashSetTreeSet自然排序定制排序IDEA 复写 hashCode 方法，为什么有 31 这个数字？常见题Set Set 接口是Collection 的子接口， set 接口没有提供额外的方法 Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个Set 集合中，则添加操作失败。 Set 判断两个对象是否相同不是使用 == 运算符，而是根据 equals() 方法 特性解读: 无序性:不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的 不可重复性:保证添加的元素按照equals()判断时，不能返回true.即：相同的元素只能添加一个 添加数据:向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和equals() HashSet 数组+链表的结构,Set接口的主要实现类,线程不安全,可以存储null值 添加过程,以HashSet为例,添加元素a: 首先调用hashCode(),计算hash值,以此hash值通过底层算法计算出在HashSet底层数组中的存放位置(索引位置) 如果此位置没有元素,a添加成功; 如果此位置有其他元素b, 则比较a和b的hash值 如果hash值不相同, a添加成功; 如果hash值相同,则调用equals方法 equals为true, 则a添加失败; 反之 LinkedHashSet extends HashSet HashSet的子类,遍历内部数据时,可以按照添加的顺序遍历 LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，但它同时使用双向链表维护元素的次序这使得元素看起来是以插入顺序保存的。 LinkedHashSet 插入性能略低于 HashSet 但在迭代访问 Set 里的全 TreeSet 可以按照添加对象的指定属性，进行排序向TreeSet中添加的数据，要求是相同类的对象 自然排序 比较两个对象是否相同的标准为：compareTo()返回0.不再是equals() BigDecimal 、 BigInteger 以及所有的数值型对应的包装类：按它们对应的数值大小进行比较 Character ：按字符的 unicode 值来进行比较 Boolean true 对应的包装类实例大于 false 对应的包装类实例 String ：按字符串中字符的 unicode 值进行比较 Date 、 Time ：后边的时间、日期比前面的时间、日期大 //自然排序 @Test public void t2(){ TreeSet set = new TreeSet(); set.add(new User(\"Tom\",12)); set.add(new User(\"Jerry\",32)); set.add(new User(\"Jim\",2)); set.add(new User(\"Mike\",65)); set.add(new User(\"Jack\",33)); set.add(new User(\"Jack\",56)); Iterator iterator = set.iterator(); while(iterator.hasNext()){ System.out.println(iterator.next()); } } //user package collection.collection; public class User implements Comparable{ private String name; private int age; public User() { } public User(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"User{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } @Override public boolean equals(Object o) { System.out.println(\"User equals()....\"); if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; User user = (User) o; if (age != user.age) return false; return name != null ? name.equals(user.name) : user.name == null; } @Override public int hashCode() { //return name.hashCode() + age; int result = name != null ? name.hashCode() : 0; result = 31 * result + age; return result; } //按照姓名从大到小排列,年龄从小到大排列 @Override public int compareTo(Object o) { System.out.println(\"User compareTo\"); if(o instanceof User){ User user = (User)o; // return -this.name.compareTo(user.name); int compare = -this.name.compareTo(user.name); if(compare != 0){ return compare; }else{ return Integer.compare(this.age,user.age); } }else{ throw new RuntimeException(\"输入的类型不匹配\"); } } } 定制排序 比较两个对象是否相同的标准为：compare()返回0.不再是equals() //定制排序 @Test public void t3(){ Comparator com = new Comparator() { //按照年龄从小到大排列 @Override public int compare(Object o1, Object o2) { if(o1 instanceof User && o2 instanceof User){ User u1 = (User)o1; User u2 = (User)o2; return Integer.compare(u1.getAge(),u2.getAge()); }else{ throw new RuntimeException(\"输入的数据类型不匹配\"); } } }; TreeSet set = new TreeSet(com); set.add(new User(\"Tom\",12)); set.add(new User(\"Jerry\",32)); set.add(new User(\"Jim\",2)); set.add(new User(\"Mike\",65)); set.add(new User(\"Mary\",33)); set.add(new User(\"Jack\",33)); set.add(new User(\"Jack\",56)); Iterator iterator = set.iterator(); while(iterator.hasNext()){ System.out.println(iterator.next()); } } IDEA 复写 hashCode 方法，为什么有 31 这个数字？ 选择系数的时候要选择尽量大的系数。因为如果计算出来的 hash 地址越大，所谓的“冲突”就越少，查找起来效率也会提高。（减少冲突) 并且 31 只占用 5bits, 相乘造成数据溢出的概率较小。 31 可以 由 i*31== (i 31 是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有 1 来整除减少冲突 常见题 //去重 @Test public void t4(){ List list = new ArrayList(); list.add(new Integer(1)); list.add(new Integer(2)); list.add(new Integer(2)); list.add(new Integer(4)); list.add(new Integer(4)); List list2 = duplicateList(list); for (Object integer : list2) { System.out.println(integer); } } public static List duplicateList(List list) { HashSet set = new HashSet(); set.addAll(list); return new ArrayList(set); } @Test public void test5(){ HashSet set = new HashSet(); User u1 = new User(\"Tom\",12); User u2 = new User(\"Jack\",15); set.add(u1); set.add(u2); System.out.println(set); u1.setName(\"cc\"); set.remove(u1);//会失败,add时是以Tom为hash值对应的位置,以cc得到的hash值不在以Tom为hash值的位置 System.out.println(set); set.add(new User(\"cc\",12));//新位置 System.out.println(set); set.add(new User(\"Tom\",12));//也能加成功,hashCode值一样,但equals的时候不一样,因为u1变为cc了 System.out.println(set); } Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-13 09:31:28 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/collection/map.html":{"url":"Chapter1/collection/map.html","title":"Map","keywords":"","body":"Map常用方法HashMapLinkedHashMap extends HashMapTreeMapHashTableProperties extends HashTableMap Map 与 Collection 并列存在。用于保存具有映射关系的数据 :key value Map 中的 key 和 value 都可以是任何引用类型的数据 Map 中的 key 用 Set 来存放，不允许重复 ，即同一个 Map 对象所对应的类，须重写 hashCode 和 equals 方法 常用 String 类作为 Map 的“键” key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到唯一的、确定的 value Map 接口的常用实现类： HashMap 、 TreeMap 、 LinkedHashMap 和Properties 。 其中， HashMap 是 Map 接口使用频率最高的实现类 常用方法 添加,删除,修改 Object put(Object key, Object value)void putAll(Map m)Object remove(Object key)Object clear() 查询 Object get(Object key)boolean containsKey(Object key)boolean containsValue(Object value)int size()boolean isEmpty()boolean equals(Object obj) 无视图操作 Set keySet() --返回所有key构成的Set集合Collection values() --返回所有value构成的Collection集合Set entrySet() --返回所有key-value构成的Set集合 HashMap 存储结构 1.7 数组+链表1.8 数组+链表+红黑树 实例化 1.7 底层创建了长度是16的一维数组 Entry[] table1.8 底层没有创建一个长度为16的数组(jdk8底层数组是Node[] ,而不是Entry[]),首次put时创建 put(k,v) 首先,调用k所在类hashCode()计算k的 hash值,此hash值经过某种算法计算以后,得到Entry数组中的存放位置如果此位置数据为空,则k-v添加成功如果此位置数据不为空(存在1个或多个数据以链表形式存在),则比较k的hash值 如果hash值不相同,则k-v添加成功如果hash值不相同,则通过k的equals方法比较 如果equals() 返回false, 则k-v添加成功如果equals() 返回true, 则使用v替换相同k的value值 1.7: 在不断扩容过程中,当超过临界值且该位置不为Null,默认的扩容方式:扩容为原来容量的2位,并把旧的数据copy过来1.8: 当数组的某一个索引位置上的元素以链表形式存在的 数据个数>8 && 当前数组长度>64时,此时索引位置上的所有数据改为使用红黑树存储 源码关键参数 DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75threshold：扩容的临界值，=容量填充因子：16 0.75 => 12TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64 加载因子的大小影响 负载 因子的大小决定了 HashMap 的数据密度。负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易 长造成 查询或插入时的比较次数增多，性能会下降。负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建议初始化预设大一点的空间。按照其他语言的参考及研究经验，会考虑将负载因子设置为 0.7~0.75 ，此时平均检索长度接近于常数 深入分析hashMap This browser does not support PDFs. Please download the PDF to view it: Download PDF. LinkedHashMap extends HashMap LinkedHashMap 是 HashMap 的 子类 在 HashMap 存储结构的基础上，使用了一对双向链表来记录添加元素的顺序 static class Entry extends HashMap.Node { Entry before, after; Entry(int hash, K key, V value, Node next) { super(hash, key, value, next); } } 与 LinkedHashSet 类似 LinkedHashMap 可以维护 Map 的迭代顺序：迭代顺序与 Key V alue 对的插入顺序一致 public class MapTest2 { @Test public void t2(){ LinkedHashMap map = new LinkedHashMap(); map.put(111, 1); map.put(222, 2); map.put(333, 3); System.out.println(map);//{111=1, 222=2, 333=3} } @Test public void t1(){ HashMap map = new HashMap(); map.put(111, 1); map.put(222, 2); map.put(333, 3); System.out.println(map);//{333=3, 222=2, 111=1} } } TreeMap TreeMap 存储 Key Value 对时，需要根据 key value 对进行排序。TreeMap 可以保证所有的 Key Value 对处于有序状态 。 TreeSet 底层使用红黑树结构存储数据 TreeMap 的 Key 的排序： 自然排序 TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException 定制排序 ：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现Comparable 接口 TreeMap 判断 两个 key 相等的标准 ：两个 key 通过 compareTo() 方法或者 compare() 方法返回 0 /** * 向TreeMap中添加key-value，要求key必须是由同一个类创建的对象 * 因为要按照key进行排序：自然排序 、定制排序 */ public class TreeMapTest { //定制排序 @Test public void test2(){ TreeMap map = new TreeMap(new Comparator() { @Override public int compare(Object o1, Object o2) { if(o1 instanceof User && o2 instanceof User){ User u1 = (User)o1; User u2 = (User)o2; return Integer.compare(u1.getAge(),u2.getAge()); } throw new RuntimeException(\"输入的类型不匹配！\"); } }); User u1 = new User(\"Tom\",23); User u2 = new User(\"Jerry\",32); User u3 = new User(\"Jack\",20); User u4 = new User(\"Rose\",18); map.put(u1,98); map.put(u2,89); map.put(u3,76); map.put(u4,100); Set entrySet = map.entrySet(); Iterator iterator1 = entrySet.iterator(); while (iterator1.hasNext()){ Object obj = iterator1.next(); Map.Entry entry = (Map.Entry) obj; System.out.println(entry.getKey() + \"---->\" + entry.getValue()); } } //自然排序 @Test public void test1(){ TreeMap map = new TreeMap(); User u1 = new User(\"Tom\",23); User u2 = new User(\"Jerry\",32); User u3 = new User(\"Jack\",20); User u4 = new User(\"Rose\",18); map.put(u1,98); map.put(u2,89); map.put(u3,76); map.put(u4,100); Set entrySet = map.entrySet(); Iterator iterator1 = entrySet.iterator(); while (iterator1.hasNext()){ Object obj = iterator1.next(); Map.Entry entry = (Map.Entry) obj; System.out.println(entry.getKey() + \"---->\" + entry.getValue()); } } } HashTable Hashtable 是个旧的 Map 实现类，JDK1.0 就提供了。不同于 HashMap,Hashtable 是线程安全的。 Hashtable 实现原理和 HashMap 相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以互用 。 与 HashMap 不同， Hashtable 不允许使用 null 作为 key 和 value 与 HashMap 一样， Hashtable 也不能保证其中 Key Value 对的顺序 Hashtable 判断两个 key 相等、两个 value 相等的标准与 HashMap一致 Properties extends HashTable Properties 类是 Hashtable 的子类，该对象用于处理属性文件 由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key和 value 都是字符串类型 存取数据时，建议使用 setProperty (String key,String value) 方法和getProperty (String) 方法 /** * 处理配置文件 * * map包下放test.properties文件 * name=zhjq * sex=female * age=18 */ public class PropertiesTest { public static void main(String[] args) throws IOException { Properties properties = new Properties(); properties.load(new FileInputStream(\"src/collection/map/test.properties\")); String name = properties.getProperty(\"name\"); System.out.println(name); Set> entries = properties.entrySet(); for (Map.Entry entry : entries) { System.out.println(entry.getKey()+\":\"+entry.getValue()); } } } Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-13 09:31:28 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/genericity/":{"url":"Chapter1/genericity/","title":"泛型","keywords":"","body":"泛型自定义泛型类,泛型接口自定义泛型方法泛型在继承上的体现通配符的使用 \"?\"有限制条件的通配符使用泛型 所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参）。 从JDK1.5以后，Java引入了“参数化类型（Parameterized type）”的概念，允许我们在创建集合时再指定集合元素的类型，正如：List，这表明该List只能保存字符串类型的对象。 JDK1.5改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类型实参 自定义泛型类,泛型接口 public class Order {} public interface List {} 泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如： 泛型类的构造器如下：public GenericClass(){}。而下面是错误的：public GenericClass(){} 实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致。 泛型不同的引用不能相互赋值。 尽管在编译时ArrayList和ArrayList是两种类型，但是，在运行时只有一个ArrayList被加载到JVM中。 泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object。经验：泛型要使用一路都用。要不用，一路都不要用。 如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象。 jdk1.7，泛型的简化操作：ArrayList flist = new ArrayList<>(); 泛型的指定中不能使用基本数据类型，可以使用包装类替换。 在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的泛型。 异常类不能是泛型的 不能使用new E[]。但是可以：E[] elements = (E[])new Object[capacity];参考：ArrayList源码中声明：Object[] elementData，而非泛型参数类型数组。 父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型： 子类不保留父类的泛型：按需实现 没有类型 擦除具体类型 子类保留父类的泛型：泛型子类 全部保留部分保留 class Father { } // 子类不保留父类的泛型 // 1)没有类型 擦除 class Son1 extends Father {// 等价于class Son extends Father{ } // 2)具体类型 class Son2 extends Father { } // 子类保留父类的泛型 // 1)全部保留 class Son3 extends Father { } // 2)部分保留 class Son4 extends Father { } // 子类不保留父类的泛型 // 1)没有类型 擦除 class Son extends Father{//等价于class Son extends Father{ } // 2)具体类型 class Son2 extends Father { } // 子类保留父类的泛型 // 1)全部保留 class Son3 extends Father { } // 2)部分保留 class Son4 extends Father { } 自定义泛型方法 [访问权限] 返回类型 方法名([泛型标识 参数名称]) 抛出的异常 public class ListUtil { //泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系。 //泛型方法所属的类是不是泛型类都没有关系。 //泛型方法，可以声明为静态的。原因：泛型参数是在调用方法时确定的。并非在实例化类时确定。 public static List copyFromArrayToList(E[] arr) { ArrayList list = new ArrayList<>(); for (E e : arr) { list.add(e); } return list; } } 泛型在继承上的体现 虽然类A是类B的父类，但是G 和G二者不具备子父类关系，二者是并列关系 类A是类B的父类，A 是 B 的父类 通配符的使用 \"?\" 类A是类B的父类，G和G是没有关系的，二者共同的父类是：G //list是 list1和list2的父类 List list1 = null; List list2 = null; List list = null; list = list1; list = list2; 不能写入, 但是写入null 可以, 通过get()方法获取的是Object类型 注意点 //注意点1：编译错误：不能用在泛型方法声明上，返回值类型前面<>不能使用? public static void test(ArrayList list){ } //注意点2：编译错误：不能用在泛型类的声明上 class GenericTypeClass{ } //注意点3：编译错误：不能用在创建对象上，右边属于创建集合对象 ArrayList list2 = new ArrayList(); 有限制条件的通配符使用 通配符指定上限 上限extends：使用时指定的类型必须是继承某个类，或者实现某个接口，即G 可以作为G和G的父类，其中B是A的子类 通配符指定下限 下限super：使用时指定的类型不能小于操作的类，即>=G 可以作为G和G的父类，其中B是A的父类 @Test public void test4() { List list1 = null; List list2 = null; List list3 = new ArrayList(); List list4 = new ArrayList(); List list5 = new ArrayList(); list1 = list3; list1 = list4; // list1 = list5;//编译不通过 // list2 = list3;//编译不通过 list2 = list4; list2 = list5; //读取数据： list1 = list3; Person p = list1.get(0); //Student s = list1.get(0);//编译不通过 list2 = list4; Object obj = list2.get(0); // Person obj = list2.get(0);//编译不通过 //写入数据： // list1.add(new Student());//编译不通过 //编译通过 list2.add(new Person()); list2.add(new Student()); } Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-13 11:11:13 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/io/":{"url":"Chapter1/io/","title":"IO与网络编程","keywords":"","body":"io与网络编程io流网络编程io与网络编程 io流 File类 IO流原理及分类 节点流 缓冲流 转换流 其他流 对象流 随机存取文件流 NIO中的Path,Paths,Files 参考nio2 网络编程 TCP UDP Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-14 09:56:58 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/io/io/file.html":{"url":"Chapter1/io/io/file.html","title":"File","keywords":"","body":"FileFile 常用构造器: public File(String pathname) 以pathname为路径创建File对象，可以是绝对路径或者相对路径，如果pathname是相对路径，则默认的当前路径在系统属性user.dir中存储。 绝对路径：是一个固定的路径,从盘符开始相对路径：是相对于某个位置开始 public File(String parent,String child) 以parent为父路径，child为子路径创建File对象。 public File(File parent,String child) 根据一个父File对象和子文件路径创建File对象 @Test public void test1() throws IOException { System.out.println(System.getProperty(\"user.dir\"));//默认路径 File file = new File(\"src/io/file/static/hello.txt\"); //创建一个与file同目录下的另外一个文件，文件名为：haha.txt File destFile = new File(file.getParent(),\"haha.txt\"); boolean newFile = destFile.createNewFile(); if(newFile){ System.out.println(\"创建成功！\"); } } 路径分隔符: 路径中的每级目录之间用一个路径分隔符隔开。 路径分隔符和系统有关： windows和DOS系统默认使用“\\”来表示 UNIX和URL使用“/”来表示 Java程序支持跨平台运行，因此路径分隔符要慎用。 为了解决这个隐患，File类提供了一个常量：public static final String separator。根据操作系统，动态的提供分隔符 常用方法: 获取 public String getAbsolutePath()：获取绝对路径public String getPath() ：获取路径public String getName() ：获取名称public String getParent()：获取上层文件目录路径。若无，返回nullpublic long length() ：获取文件长度（即：字节数）。不能获取目录的长度。public long lastModified() ：获取最后一次的修改时间，毫秒值public String[] list() ：获取指定目录下的所有文件或者文件目录的名称数组public File[] listFiles() ：获取指定目录下的所有文件或者文件目录的File数组 重命名 public boolean renameTo(File dest):把文件重命名为指定的文件路径 判断 public boolean isDirectory()：判断是否是文件目录public boolean isFile() ：判断是否是文件public boolean exists() ：判断是否存在public boolean canRead() ：判断是否可读public boolean canWrite() ：判断是否可写public boolean isHidden() ：判断是否隐藏 创建 public boolean createNewFile() ：创建文件。若文件存在，则不创建，返回falsepublic boolean mkdir() ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。public boolean mkdirs() ：创建文件目录。如果上层文件目录不存在，一并创建注意事项：如果你创建文件或者文件目录没有写盘符路径，那么，默认在项目路径下 删除 public boolean delete()：删除文件或者文件夹删除注意事项：Java中的删除不走回收站。 要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录 常见案例: /** * 遍历指定目录所有文件名称，包括子文件目录中的文件。 * 拓展1：并计算指定目录占用空间的大小 * 拓展2：删除指定文件目录及其下的所有文件 */ public class ListFilesTest { public static void main(String[] args) { // 递归:文件目录 /** 打印出指定目录所有文件名称，包括子文件目录中的文件 */ // 1.创建目录对象 File dir = new File(\"src/io/file\"); // 2.打印目录的子文件 System.out.println(\"------遍历目录下文件及子文件--------\"); printSubFile(dir); System.out.println(\"------遍历目录--------\"); listSubFiles(dir); System.out.println(\"-------遍历目录下文件及子文件-------\"); listAllSubFiles(dir); System.out.println(\"------列出指定目录大小--------\"); System.out.println(getDirectorySize(dir)); } public static void printSubFile(File dir) { // 打印目录的子文件 File[] subfiles = dir.listFiles(); for (File f : subfiles) { if (f.isDirectory()) {// 文件目录 printSubFile(f); } else {// 文件 System.out.println(f.getAbsolutePath()); } } } // 方式二：循环实现 // 列出file目录的下级内容，仅列出一级的话 // 使用File类的String[] list()比较简单 public static void listSubFiles(File file) { if (file.isDirectory()) { String[] all = file.list(); for (String s : all) { System.out.println(s); } } else { System.out.println(file + \"是文件！\"); } } // 列出file目录的下级，如果它的下级还是目录，接着列出下级的下级，依次类推 // 建议使用File类的File[] listFiles() public static void listAllSubFiles(File file) { if (file.isFile()) { System.out.println(file); } else { File[] all = file.listFiles(); // 如果all[i]是文件，直接打印 // 如果all[i]是目录，接着再获取它的下一级 for (File f : all) { listAllSubFiles(f);// 递归调用：自己调用自己就叫递归 } } } // 拓展1：求指定目录所在空间的大小 // 求任意一个目录的总大小 public static long getDirectorySize(File file) { // file是文件，那么直接返回file.length() // file是目录，把它的下一级的所有大小加起来就是它的总大小 long size = 0; if (file.isFile()) { size += file.length(); } else { File[] all = file.listFiles();// 获取file的下一级 // 累加all[i]的大小 for (File f : all) { size += getDirectorySize(f);// f的大小; } } return size; } // 拓展2：删除指定的目录 public static void deleteDirectory(File file) { // 如果file是文件，直接delete // 如果file是目录，先把它的下一级干掉，然后删除自己 if (file.isDirectory()) { File[] all = file.listFiles(); // 循环删除的是file的下一级 for (File f : all) {// f代表file的每一个下级 deleteDirectory(f); } } // 删除自己 file.delete(); } } Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-14 11:02:34 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/io/io/io.html":{"url":"Chapter1/io/io/io.html","title":"IO流原理及分类","keywords":"","body":"IO流原理及分类分类InputStreamReaderOutputStreamWriterIO流原理及分类 I/O是Input/Output的缩写， I/O技术是非常实用的技术，用于处理设备之间的数据传输。如读/写文件，网络通讯等。 Java程序中，对于数据的输入/输出操作以“流(stream)” 的方式进行。 java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过标准的方法输入或输出数据 输入input：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。 输出output：将程序（内存）数据输出到磁盘、光盘等存储设备中。 分类 按操作数据单位不同分为：字节流(8 bit)，字符流(16 bit) 按数据流的流向不同分为：输入流，输出流 按流的角色的不同分为：节点流，处理流 节点流: 直接从数据源或目的地读写数据处理流: 不直接连接到数据源或目的地，而是“连接”在已存在的流（节点流或处理流）之上，通过对数据的处理为程序提供更为强大的读写功能 分类 字节输入流 字节输出流 字符输入流 字符输出流 抽象基类 InputStream OutputStream Reader Writer 访问文件 FileInputStream FileOutputStream FileReader FileWriter 访问数组 ByteArrayInputStream ByteArrayOutputStream CharArrayReader CharArrayWriter 访问管道 PipedInputStream PipedOutputStream PipedReader PipedWriter 访问字符串 StringReader StringWriter 缓冲流 BufferedInputStream BufferedOutputStream BufferedReader BufferedWriter 转换流 InputStreamReader OutputStreamWriter 对象流 ObjectInputStream ObjectOutputStream FilterInputStream FilterOutputStream FilterReader FilterWriter 打印流 PrintStream PrintWriter 推回输入流 PushbackStream PushbackReader 特殊流 DataInputStream DataOutputStream InputStream int read()从输入流中读取数据的下一个字节。返回 0 到 255 范围内的 int 字节值。如果因为已经到达流末尾而没有可用的字节，则返回值 -1。 int read(byte[] b)从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。如果因为已经到达流末尾而没有可用的字节，则返回值 -1。否则以整数形式返回实际读取的字节数。 int read(byte[] b, int off,int len)将输入流中最多 len 个数据字节读入 byte 数组。尝试读取 len 个字节，但读取的字节也可能小于该值。以整数形式返回实际读取的字节数。如果因为流位于文件末尾而没有可用的字节，则返回值 -1。 public void close() throws IOException关闭此输入流并释放与该流关联的所有系统资源。 Reader int read()读取单个字符。作为整数读取的字符，范围在 0 到 65535 之间 (0x00-0xffff)（2个字节的Unicode码），如果已到达流的末尾，则返回 -1 int read(char[] cbuf)将字符读入数组。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。 int read(char[] cbuf,int off,int len)将字符读入数组的某一部分。存到数组cbuf中，从off处开始存储，最多读len个字符。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。 public void close() throws IOException关闭此输入流并释放与该流关联的所有系统资源。 OutputStream void write(int b)将指定的字节写入此输出流。write 的常规协定是：向输出流写入一个字节。要写入的字节是参数 b 的八个低位。b 的 24 个高位将被忽略。 即写入0~255范围的。 void write(byte[] b)将 b.length 个字节从指定的 byte 数组写入此输出流。write(b) 的常规协定是：应该与调用 write(b, 0, b.length) 的效果完全相同。 void write(byte[] b,int off,int len)将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。 public void flush()throws IOException刷新此输出流并强制写出所有缓冲的输出字节，调用此方法指示应将这些字节立即写入它们预期的目标。 public void close() throws IOException关闭此输出流并释放与该流关联的所有系统资源 Writer void write(int c)写入单个字符。要写入的字符包含在给定整数值的 16 个低位中，16 高位被忽略。 即写入0 到 65535 之间的Unicode码。 void write(char[] cbuf)写入字符数组。 void write(char[] cbuf,int off,int len)写入字符数组的某一部分。从off开始，写入len个字符 void write(String str)写入字符串。 void write(String str,int off,int len)写入字符串的某一部分。 void flush()刷新该流的缓冲，则立即将它们写入预期目标。 public void close() throws IOException关闭此输出流并释放与该流关联的所有系统资源 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-14 09:29:14 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/io/io/fileStream.html":{"url":"Chapter1/io/io/fileStream.html","title":"节点流","keywords":"","body":"节点流(文件流)字符流 FileReader FileWriter字节流 FileInputStream FileOutputStream注意点节点流(文件流) 字符流 FileReader FileWriter /** * * 一、流的分类： * 1.操作数据单位：字节流、字符流 * 2.数据的流向：输入流、输出流 * 3.流的角色：节点流、处理流 * * 二、流的体系结构 * 抽象基类 节点流（或文件流） 缓冲流（处理流的一种） * InputStream FileInputStream (read(byte[] buffer)) BufferedInputStream (read(byte[] buffer)) * OutputStream FileOutputStream (write(byte[] buffer,0,len) BufferedOutputStream (write(byte[] buffer,0,len) / flush() * Reader FileReader (read(char[] cbuf)) BufferedReader (read(char[] cbuf) / readLine()) * Writer FileWriter (write(char[] cbuf,0,len) BufferedWriter (write(char[] cbuf,0,len) / flush() */ public class FileReaderWriterTest { public static void main(String[] args) { File file = new File(\"src/io/io/static/hello1.txt\");//相较于当前工程 System.out.println(file.getAbsolutePath()); File file1 = new File(\"src/io/io/static/hello2.txt\"); System.out.println(file1.getAbsolutePath()); } /* 读取hello1.txt内容并输出到控制台 说明点： 1. read()的理解：返回读入的一个字符。如果达到文件末尾，返回-1 2. 异常的处理：为了保证流资源一定可以执行关闭操作。需要使用try-catch-finally处理 3. 读入的文件一定要存在，否则就会报FileNotFoundException。 */ @Test public void testFileReader(){ FileReader fr = null; try { //1.实例化File类的对象，指明要操作的文件 File file = new File(\"src/io/io/static/hello1.txt\");//相较于当前Module //2.提供具体的流 fr = new FileReader(file); //3.数据的读入 //read():返回读入的一个字符。如果达到文件末尾，返回-1 //方式一： // int data = fr.read(); // while(data != -1){ // System.out.print((char)data); // data = fr.read(); // } //方式二：语法上针对于方式一的修改 int data; while((data = fr.read()) != -1){ System.out.print((char)data); } } catch (IOException e) { e.printStackTrace(); } finally { //4.流的关闭操作 // try { // if(fr != null) // fr.close(); // } catch (IOException e) { // e.printStackTrace(); // } //或 if(fr != null){ try { fr.close(); } catch (IOException e) { e.printStackTrace(); } } } } //对read()操作升级：使用read的重载方法 @Test public void testFileReader1() { FileReader fr = null; try { //1.File类的实例化 File file = new File(\"src/io/io/static/hello1.txt\"); //2.FileReader流的实例化 fr = new FileReader(file); //3.读入的操作 //read(char[] cbuf):返回每次读入cbuf数组中的字符的个数。如果达到文件末尾，返回-1 char[] cbuf = new char[5]; int len; while((len = fr.read(cbuf)) != -1){ //方式一： //错误的写法 // for(int i = 0;i 字节流 FileInputStream FileOutputStream /** * 测试FileInputStream和FileOutputStream的使用 * * 结论： * 1. 对于文本文件(.txt,.java,.c,.cpp)，使用字符流处理 * 2. 对于非文本文件(.jpg,.mp3,.mp4,.avi,.doc,.ppt,...)，使用字节流处理 */ public class FileInputOutputStreamTest { //使用字节流FileInputStream处理文本文件，可能出现乱码。 @Test public void testFileInputStream() { FileInputStream fis = null; try { //1. 打开文件 File file = new File(\"src/io/io/static/hello1.txt\"); //2.造流 fis = new FileInputStream(file); //3.读数据 byte[] buffer = new byte[5]; int len;//记录每次读取的字节的个数 while((len = fis.read(buffer)) != -1){ String str = new String(buffer,0,len); System.out.print(str); } } catch (IOException e) { e.printStackTrace(); } finally { if(fis != null){ //4.关闭资源 try { fis.close(); } catch (IOException e) { e.printStackTrace(); } } } } /* 实现对图片的复制操作: 字节流成功 */ @Test public void testFileInputOutputStream() { FileInputStream fis = null; FileOutputStream fos = null; try { File srcFile = new File(\"src/io/io/static/beauty.jpg\"); File destFile = new File(\"src/io/io/static/beauty2.jpg\"); fis = new FileInputStream(srcFile); fos = new FileOutputStream(destFile); //复制的过程 byte[] buffer = new byte[5]; int len; while((len = fis.read(buffer)) != -1){ fos.write(buffer,0,len); } } catch (IOException e) { e.printStackTrace(); } finally { if(fos != null){ // try { fos.close(); } catch (IOException e) { e.printStackTrace(); } } if(fis != null){ try { fis.close(); } catch (IOException e) { e.printStackTrace(); } } } } //指定路径下文件的复制 public void copyFile(String srcPath,String destPath){ FileInputStream fis = null; FileOutputStream fos = null; try { // File srcFile = new File(srcPath); File destFile = new File(destPath); // fis = new FileInputStream(srcFile); fos = new FileOutputStream(destFile); //复制的过程 byte[] buffer = new byte[1024]; int len; while((len = fis.read(buffer)) != -1){ fos.write(buffer,0,len); } } catch (IOException e) { e.printStackTrace(); } finally { if(fos != null){ // try { fos.close(); } catch (IOException e) { e.printStackTrace(); } } if(fis != null){ try { fis.close(); } catch (IOException e) { e.printStackTrace(); } } } } @Test public void testCopyFile(){ long start = System.currentTimeMillis(); //视频太大,可自行找较大的视频测试 String srcPath = \"video.avi\"; String destPath = \"video2.avi\"; copyFile(srcPath,destPath); long end = System.currentTimeMillis(); System.out.println(\"复制操作花费的时间为：\" + (end - start)); } } 注意点 在写入一个文件时，如果使用构造器FileOutputStream(file)，则目录下有同名文件将被覆盖。 如果使用构造器FileOutputStream(file,true)，则目录下的同名文件不会被覆盖，在文件内容末尾追加内容。 在读取文件时，必须保证该文件已存在，否则报异常。 字节流操作字节，比如：.mp3，.avi，.rmvb，mp4，.jpg，.doc，.ppt 字符流操作字符，只能操作普通文本文件。最常见的文本文件：.txt，.java，.c，.cpp 等语言的源代码。尤其注意.doc,excel,ppt这些不是文本文件。 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-14 09:29:14 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/io/io/bufferStream.html":{"url":"Chapter1/io/io/bufferStream.html","title":"缓冲流","keywords":"","body":"缓冲流缓冲流 为了 提高数据读写的速度 Java API 提供了带缓冲功能的流类，在使用这些流类时，会创建一个内部 缓冲区数组，缺省使用 8192 个 字节 8Kb) 的缓冲区 缓冲 流要“套接”在相应的节点流之上，根据 数据操作单位可以把缓冲流分为： BufferedInputStream 和 BufferedOutputStreamBufferedReader 和 BufferedWriter 当读取数据时，数据按块读入缓冲区，其后的读操作则直接访问缓冲区 当使用BufferedInputStream读取字节文件时，BufferedInputStream会一次性从文件中读取8192个(8Kb)，存在缓冲区中，直到缓冲区装满了，才重新从文件中读取下一个8192个字节数组。 向流中写入字节时，不会直接写到文件，先写到缓冲区中直到缓冲区写满，BufferedOutputStream才会把缓冲区中的数据一次性写到文件里。使用方法flush()可以强制将缓冲区的内容全部写入输出流 关闭流的顺序和打开流的顺序相反。只要关闭最外层流即可，关闭最外层流也会相应关闭内层节点流 flush()方法的使用：手动将buffer中内容写入文件 如果是带缓冲区的流对象的close()方法，不但会关闭流，还会在关闭流之前刷新缓冲区，关闭后不能再写出 public class BufferedTest { /* 实现非文本文件的复制 */ @Test public void BufferedStreamTest() throws FileNotFoundException { BufferedInputStream bis = null; BufferedOutputStream bos = null; try { //1.造文件 File srcFile = new File(\"src/io/io/static/beauty.jpg\\\"\"); File destFile = new File(\"src/io/io/static/beauty.jpg\\\"\"); //2.造流 //2.1 造节点流 FileInputStream fis = new FileInputStream((srcFile)); FileOutputStream fos = new FileOutputStream(destFile); //2.2 造缓冲流 bis = new BufferedInputStream(fis); bos = new BufferedOutputStream(fos); //3.复制的细节：读取、写入 byte[] buffer = new byte[10]; int len; while((len = bis.read(buffer)) != -1){ bos.write(buffer,0,len); // bos.flush();//刷新缓冲区 } } catch (IOException e) { e.printStackTrace(); } finally { //4.资源关闭 //要求：先关闭外层的流，再关闭内层的流 if(bos != null){ try { bos.close(); } catch (IOException e) { e.printStackTrace(); } } if(bis != null){ try { bis.close(); } catch (IOException e) { e.printStackTrace(); } } //说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略. // fos.close(); // fis.close(); } } //实现文件复制的方法 public void copyFileWithBuffered(String srcPath,String destPath){ BufferedInputStream bis = null; BufferedOutputStream bos = null; try { //1.造文件 File srcFile = new File(srcPath); File destFile = new File(destPath); //2.造流 //2.1 造节点流 FileInputStream fis = new FileInputStream((srcFile)); FileOutputStream fos = new FileOutputStream(destFile); //2.2 造缓冲流 bis = new BufferedInputStream(fis); bos = new BufferedOutputStream(fos); //3.复制的细节：读取、写入 byte[] buffer = new byte[1024]; int len; while((len = bis.read(buffer)) != -1){ bos.write(buffer,0,len); } } catch (IOException e) { e.printStackTrace(); } finally { //4.资源关闭 //要求：先关闭外层的流，再关闭内层的流 if(bos != null){ try { bos.close(); } catch (IOException e) { e.printStackTrace(); } } if(bis != null){ try { bis.close(); } catch (IOException e) { e.printStackTrace(); } } //说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略. // fos.close(); // fis.close(); } } @Test public void testCopyFileWithBuffered(){ long start = System.currentTimeMillis(); String srcPath = \"src/io/io/static/beauty.jpg\"; String destPath = \"src/io/io/static/beauty2.jpg\"; copyFileWithBuffered(srcPath,destPath); long end = System.currentTimeMillis(); System.out.println(\"复制操作花费的时间为：\" + (end - start));//618 - 176 } /* 使用BufferedReader和BufferedWriter实现文本文件的复制 */ @Test public void testBufferedReaderBufferedWriter(){ BufferedReader br = null; BufferedWriter bw = null; try { //创建文件和相应的流 br = new BufferedReader(new FileReader(new File(\"src/io/io/static/hello1.txt\"))); bw = new BufferedWriter(new FileWriter(new File(\"src/io/io/static/hello3.txt\"))); //读写操作 //方式一：使用char[]数组 // char[] cbuf = new char[1024]; // int len; // while((len = br.read(cbuf)) != -1){ // bw.write(cbuf,0,len); // // bw.flush(); // } //方式二：使用String String data; while((data = br.readLine()) != null){ //方法一： // bw.write(data + \"\\n\");//data中不包含换行符 //方法二： bw.write(data);//data中不包含换行符 bw.newLine();//提供换行的操作 } } catch (IOException e) { e.printStackTrace(); } finally { //关闭资源 if(bw != null){ try { bw.close(); } catch (IOException e) { e.printStackTrace(); } } if(br != null){ try { br.close(); } catch (IOException e) { e.printStackTrace(); } } } } } Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-14 11:05:34 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/io/io/conversionStream.html":{"url":"Chapter1/io/io/conversionStream.html","title":"转换流","keywords":"","body":"转换流InputStreamReaderOutputStreamWriter转换流 转换流提供了在字节流和字符流之间的转换 Java API提供了两个转换流： InputStreamReader：将InputStream转换为ReaderOutputStreamWriter：将Writer转换为OutputStream 字节流中的数据都是字符时，转成字符流操作更高效。 * 很多时候我们使用转换流来处理文件乱码问题。实现编码和解码的功能。 InputStreamReader 实现将字节的输入流按指定字符集转换为字符的输入流。 需要和InputStream“套接”。 构造器 public InputStreamReader(InputStream in)public InputSreamReader(InputStream in,String charsetName) OutputStreamWriter 实现将字符的输出流按指定字符集转换为字节的输出流。 需要和OutputStream“套接”。 构造器 public OutputStreamWriter(OutputStream out)public OutputSreamWriter(OutputStream out,String charsetName) @Test public void test2() throws Exception { //1.造文件、造流 File file1 = new File(\"src/io/io/static/hello1.txt\"); File file2 = new File(\"src/io/io/static/hello4.txt\"); FileInputStream fis = new FileInputStream(file1); FileOutputStream fos = new FileOutputStream(file2); InputStreamReader isr = new InputStreamReader(fis, \"utf-8\"); OutputStreamWriter osw = new OutputStreamWriter(fos, \"gbk\"); //2.读写过程 char[] cbuf = new char[20]; int len; while ((len = isr.read(cbuf)) != -1) { osw.write(cbuf, 0, len); } //3.关闭资源 isr.close(); osw.close(); } Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-14 09:54:11 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/io/io/charset.html":{"url":"Chapter1/io/io/charset.html","title":"编码","keywords":"","body":"编码有关编码的基础知识常见的编码表编码 有关编码的基础知识 位 bit 最小的单元: 字节 byte 机器语言的单位 1byte=8bits 1KB=1024byte1MB=1024KB1GB=1024MB 进制 二进制 binary八进制 octal十进制 decimal十六进制 hex 字符：是各种文字和符号的总称,包括各个国家的文字,标点符号,图形符号,数字等 字符集：字符集是多个符号的集合, 每个字符集包含的字符个数不同 字符编码：字符集只是规定了有哪些字符,而最终决定采用哪些字符,每一个字符用多少字节表示等问题,则是由编码来决定的.计算机要准确的处理各种字符集文字,需要进行字符编码,以便计算机能够识别和存储各种文字 常见的编码表 ASCII：美国标准信息交换码。用一个字节的7位可以表示。 ISO8859-1：拉丁码表。欧洲码表,用一个字节的8位表示。 GB2312：中国的中文编码表。最多两个字节编码所有字符 GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码 Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。 UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。 Unicode字符集只是定义了字符的集合和唯一编号，Unicode编码，则是对UTF-8、UCS-2/UTF-16等具体编码方案的统称而已，并不是具体的编码方案。 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-14 09:29:14 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/io/io/otherStream.html":{"url":"Chapter1/io/io/otherStream.html","title":"其他流","keywords":"","body":"标准输入,输出流打印流数据流标准输入,输出流 System.in和System.out分别代表了系统标准的输入和输出设备 默认输入设备是：键盘，输出设备是：显示器 System.in的类型是InputStream System.out的类型是PrintStream，其是OutputStream的子类,FilterOutputStream 的子类 重定向：通过System类的setIn，setOut方法对默认设备进行改变。 public static void setIn(InputStream in)public static void setOut(PrintStream out) /* 1.标准的输入、输出流 1.1 System.in:标准的输入流，默认从键盘输入 System.out:标准的输出流，默认从控制台输出 1.2 System类的setIn(InputStream is) / setOut(PrintStream ps)方式重新指定输入和输出的流。 1.3练习： 从键盘输入字符串，要求将读取到的整行字符串转成大写输出。然后继续进行输入操作， 直至当输入“e”或者“exit”时，退出程序。 方法一：使用Scanner实现，调用next()返回一个字符串 方法二：使用System.in实现。System.in ---> 转换流 ---> BufferedReader的readLine() */ public static void main(String[] args) { BufferedReader br = null; try { InputStreamReader isr = new InputStreamReader(System.in); br = new BufferedReader(isr); while (true) { System.out.println(\"请输入字符串：\"); String data = br.readLine(); if (\"e\".equalsIgnoreCase(data) || \"exit\".equalsIgnoreCase(data)) { System.out.println(\"程序结束\"); break; } String upperCase = data.toUpperCase(); System.out.println(upperCase); } } catch (IOException e) { e.printStackTrace(); } finally { if (br != null) { try { br.close(); } catch (IOException e) { e.printStackTrace(); } } } } 打印流 实现将基本数据类型的数据格式转化为字符串输出 打印流：PrintStream和PrintWriter 提供了一系列重载的print()和println()方法，用于多种数据类型的输出PrintStream和PrintWriter的输出不会抛出IOException异常PrintStream和PrintWriter有自动flush功能PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter 类。System.out返回的是PrintStream的实例 /* 2. 打印流：PrintStream 和PrintWriter 2.1 提供了一系列重载的print() 和 println() */ @Test public void test2() { PrintStream ps = null; try { FileOutputStream fos = new FileOutputStream(new File(\"src/io/io/static/hello1.txt\")); // 创建打印输出流,设置为自动刷新模式(写入换行符或字节 '\\n' 时都会刷新输出缓冲区) ps = new PrintStream(fos, true); if (ps != null) {// 把标准输出流(控制台输出)改成文件 System.setOut(ps); } for (int i = 0; i 数据流 /* 3. 数据流 3.1 DataInputStream 和 DataOutputStream 3.2 作用：用于读取或写出基本数据类型的变量或字符串 练习：将内存中的字符串、基本数据类型的变量写出到文件中。 注意：处理异常的话，仍然应该使用try-catch-finally. */ @Test public void test3() throws IOException { //1. DataOutputStream dos = new DataOutputStream(new FileOutputStream(\"src/io/io/static/hello1.txt\")); //2. dos.writeUTF(\"刘建辰\"); dos.flush();//刷新操作，将内存中的数据写入文件 dos.writeInt(23); dos.flush(); dos.writeBoolean(true); dos.flush(); //3. dos.close(); } /* 将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中。 注意点：读取不同类型的数据的顺序要与当初写入文件时，保存的数据的顺序一致！ */ @Test public void test4() throws IOException { //1. DataInputStream dis = new DataInputStream(new FileInputStream(\"src/io/io/static/hello1.txt\")); //2. String name = dis.readUTF(); int age = dis.readInt(); boolean isMale = dis.readBoolean(); System.out.println(\"name = \" + name); System.out.println(\"age = \" + age); System.out.println(\"isMale = \" + isMale); //3. dis.close(); } Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-14 11:07:19 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/io/io/objectStream.html":{"url":"Chapter1/io/io/objectStream.html","title":"对象流","keywords":"","body":"对象流序列化示例对象流 ObjectInputStream和OjbectOutputSteam 用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。 序列化：用ObjectOutputStream类保存基本类型数据或对象的机制 反序列化：用ObjectInputStream类读取基本类型数据或对象的机制 ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量 序列化 对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。//当其它程序获取了这种二进制流，就可以恢复成原来的Java对象 序列化的好处在于可将任何实现了Serializable接口的对象转化为字节数据，使其在保存和传输时可被还原 序列化是 RMI（Remote Method Invoke – 远程方法调用）过程的参数和返回值都必须实现的机制，而 RMI 是 JavaEE 的基础。因此序列化机制是JavaEE 平台的基础 如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一。否则，会抛出NotSerializableException异常 SerializableExternalizable 凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量： private static final long serialVersionUID;serialVersionUID用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象 进行版本控制，有关各版本反序列化时是否兼容。如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID 可能发生变化。故建议，显式声明。 简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。(InvalidCastException) 示例 public class ObjectInputOutputStreamTest { /* 序列化过程：将内存中的java对象保存到磁盘中或通过网络传输出去 使用ObjectOutputStream实现 */ @Test public void testObjectOutputStream(){ ObjectOutputStream oos = null; try { //1. oos = new ObjectOutputStream(new FileOutputStream(\"src/io/io/static/object.dat\")); //2. oos.writeObject(new String(\"我爱北京天安门\")); oos.flush();//刷新操作 oos.writeObject(new Person(\"王铭\",23)); oos.flush(); oos.writeObject(new Person(\"张学良\",23,1001,new Account(5000))); oos.flush(); } catch (IOException e) { e.printStackTrace(); } finally { if(oos != null){ //3. try { oos.close(); } catch (IOException e) { e.printStackTrace(); } } } } /* 反序列化：将磁盘文件中的对象还原为内存中的一个java对象 使用ObjectInputStream来实现 */ @Test public void testObjectInputStream(){ ObjectInputStream ois = null; try { ois = new ObjectInputStream(new FileInputStream(\"src/io/io/static/object.dat\")); Object obj = ois.readObject(); String str = (String) obj; Person p = (Person) ois.readObject(); Person p1 = (Person) ois.readObject(); System.out.println(str); System.out.println(p); System.out.println(p1); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } finally { if(ois != null){ try { ois.close(); } catch (IOException e) { e.printStackTrace(); } } } } } //Person类 /** * Person需要满足如下的要求，方可序列化 * 1.需要实现接口：Serializable * 2.当前类提供一个全局常量：serialVersionUID * 3.除了当前Person类需要实现Serializable接口之外，还必须保证其内部所有属性 * 也必须是可序列化的。（默认情况下，基本数据类型可序列化） * 补充：ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量 */ public class Person implements Serializable{ public static final long serialVersionUID = 475463534532L; private String name; private int age; private int id; private Account acct; public Person(String name, int age, int id) { this.name = name; this.age = age; this.id = id; } public Person(String name, int age, int id, Account acct) { this.name = name; this.age = age; this.id = id; this.acct = acct; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + \", id=\" + id + \", acct=\" + acct + '}'; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Person(String name, int age) { this.name = name; this.age = age; } public Person() { } } class Account implements Serializable{ public static final long serialVersionUID = 4754534532L; private double balance; @Override public String toString() { return \"Account{\" + \"balance=\" + balance + '}'; } public double getBalance() { return balance; } public void setBalance(double balance) { this.balance = balance; } public Account(double balance) { this.balance = balance; } } Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-14 09:29:14 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/io/io/randomAccessFile.html":{"url":"Chapter1/io/io/randomAccessFile.html","title":"随机存取文件流 ","keywords":"","body":"随机存取文件流RandomAccessFie随机存取文件流 RandomAccessFile 声明在java.io包下，但直接继承于java.lang.Object类。并且它实现了DataInput、DataOutput这两个接口，也就意味着这个类既可以读也可以写。 RandomAccessFile 类支持 “随机访问” 的方式，程序可以直接跳到文件的任意地方来读、写文件 支持只访问文件的部分内容可以向已存在的文件后追加内容 RandomAccessFile 对象包含一个记录指针，用以标示当前读写处的位置。RandomAccessFile 类对象可以自由移动记录指针： long getFilePointer()：获取文件记录指针的当前位置void seek(long pos)：将文件记录指针定位到 pos 位置 RandomAccessFie 构造器 public RandomAccessFile(File file, String mode)public RandomAccessFile(String name, String mode) 创建 RandomAccessFile 类实例需要指定一个 mode 参数，该参数指定 RandomAccessFile 的访问模式： r: 以只读方式打开rw：打开以便读取和写入rwd:打开以便读取和写入；同步文件内容的更新rws:打开以便读取和写入；同步文件内容和元数据的更新 如果模式为只读r。则不会创建文件，而是会去读取一个已经存在的文件，如果读取的文件不存在则会出现异常。 如果模式为rw读写。如果文件不存在则会去创建文件，如果存在则不会创建 我们可以用RandomAccessFile这个类，来实现一个多线程断点下载的功能，用过下载工具的朋友们都知道，下载前都会建立两个临时文件，一个是与被下载文件大小相同的空文件，另一个是记录文件指针的位置文件，每次暂停的时候，都会保存上一次的指针，然后断点下载的时候，会继续从上一次的地方下载，从而实现断点下载或上传的功能，有兴趣的朋友们可以自己实现下 /** * RandomAccessFile的使用 * 1.RandomAccessFile直接继承于java.lang.Object类，实现了DataInput和DataOutput接口 * 2.RandomAccessFile既可以作为一个输入流，又可以作为一个输出流 * 3.如果RandomAccessFile作为输出流时，写出到的文件如果不存在，则在执行过程中自动创建。 * 如果写出到的文件存在，则会对原有文件内容进行覆盖。（默认情况下，从头覆盖） * 4. 可以通过相关的操作，实现RandomAccessFile“插入”数据的效果 */ public class RandomAccessFileTest { @Test public void test1() { RandomAccessFile raf1 = null; RandomAccessFile raf2 = null; try { //1. raf1 = new RandomAccessFile(new File(\"src/io/io/static/beauty.jpg\"),\"r\"); raf2 = new RandomAccessFile(new File(\"src/io/io/static/beauty3.jpg\"),\"rw\"); //2. byte[] buffer = new byte[1024]; int len; while((len = raf1.read(buffer)) != -1){ raf2.write(buffer,0,len); } } catch (IOException e) { e.printStackTrace(); } finally { //3. if(raf1 != null){ try { raf1.close(); } catch (IOException e) { e.printStackTrace(); } } if(raf2 != null){ try { raf2.close(); } catch (IOException e) { e.printStackTrace(); } } } } //覆盖 @Test public void test2() throws IOException { RandomAccessFile raf1 = new RandomAccessFile(\"src/io/io/static/hello1.txt\",\"rw\"); raf1.seek(3);//将指针调到角标为3的位置 raf1.write(\"xyz\".getBytes());// raf1.close(); } /* 使用RandomAccessFile实现数据的插入效果 */ @Test public void test3() throws IOException { RandomAccessFile raf1 = new RandomAccessFile(\"src/io/io/static/hello1.txt\",\"rw\"); raf1.seek(3);//将指针调到角标为3的位置 //保存指针3后面的所有数据到StringBuilder中 StringBuilder builder = new StringBuilder((int) new File(\"src/io/io/static/hello1.txt\").length()); byte[] buffer = new byte[20]; int len; while((len = raf1.read(buffer)) != -1){ builder.append(new String(buffer,0,len)) ; } //调回指针，写入“xyz” raf1.seek(3); raf1.write(\"xyz\".getBytes()); //将StringBuilder中的数据写入到文件中 raf1.write(builder.toString().getBytes()); raf1.close(); //思考：将StringBuilder替换为ByteArrayOutputStream } } Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-14 09:50:24 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/io/net/net.html":{"url":"Chapter1/io/net/net.html","title":"网络编程 ","keywords":"","body":"网络编程网络通信协议InetAddress 类网络协议TCP/IP协议簇TCP和UDPSocketTCP网络编程(基于socket)UDP网络编程(基于socket)DatagramSocket常用方法DatagramPacket常用方法URL类构造器属性针对HTTP协议的URLConnection类URI、URL和URN的区别网络编程 网络通信协议 网络编程中的两个要素： IP和端口号 提供网络通信协议：TCP/IP参考模型（应用层、传输层、网络层、物理+数据链路层） InetAddress 类 InetAddress类没有提供公共的构造器，而是提供了如下几个静态方法来获取InetAddress实例 public static InetAddress getLocalHost()public static InetAddress getByName(String host) InetAddress提供了如下几个常用的方法 public String getHostAddress()：返回 IP 地址字符串（以文本表现形式）public String getHostName()：获取此 IP 地址的主机名public boolean isReachable(int timeout)：测试是否可以达到该地址 public class InetAddressTest { public static void main(String[] args) { try { //File file = new File(\"hello.txt\"); InetAddress inet1 = InetAddress.getByName(\"192.168.10.14\"); System.out.println(inet1); InetAddress inet2 = InetAddress.getByName(\"blog.zhaojq.top\"); System.out.println(inet2); InetAddress inet3 = InetAddress.getByName(\"127.0.0.1\"); System.out.println(inet3); //获取本地ip InetAddress inet4 = InetAddress.getLocalHost(); System.out.println(inet4); //getHostName() System.out.println(inet2.getHostName()); //getHostAddress() System.out.println(inet2.getHostAddress()); } catch (UnknownHostException e) { e.printStackTrace(); } } } 网络协议 网络通信协议计算机网络中实现通信必须有一些约定，即通信协议，对速率、传输代码、代码结构、传输控制步骤、出错控制等制定标准。 问题：网络协议太复杂计算机网络通信涉及内容很多，比如指定源地址和目标地址，加密解密，压缩解压缩，差错控制，流量控制，路由控制，如何实现如此复杂的网络协议呢？ 通信协议分层的思想在制定协议时，把复杂成份分解成一些简单的成份，再将它们复合起来。最常用的复合方式是层次方式，即同层间可以通信、上一层可以调用下一层，而与再下一层不发生关系。各层互不影响，利于系统的开发和扩展 TCP/IP协议簇 传输层协议中有两个非常重要的协议： 传输控制协议TCP(Transmission Control Protocol)用户数据报协议UDP(User Datagram Protocol)。 TCP/IP 以其两个主要协议：传输控制协议(TCP)和网络互联协议(IP)而得名，实际上是一组协议，包括多个具有不同功能且互为关联的协议。 IP(Internet Protocol)协议是网络层的主要协议，支持网间互连的数据通信。 TCP/IP协议模型从更实用的角度出发，形成了高效的四层体系结构，即物理链路层、IP层、传输层和应用层 TCP和UDP TCP协议： 使用TCP协议前，须先建立TCP连接，形成传输数据通道传输前，采用“三次握手”方式，点对点通信，是可靠的TCP协议进行通信的两个应用进程：客户端、服务端在连接中可进行大数据量的传输传输完毕，需释放已建立的连接，效率低 UDP协议： 将数据、源、目的封装成数据包，不需要建立连接每个数据报的大小限制在64K内 > 发送不管对方是否准备好，接收方收到也不确认，故是不可靠的可以广播发送发送数据结束时无需释放资源，开销小，速度快 Socket 利用套接字(Socket)开发网络应用程序早已被广泛的采用，以至于成为事实上的标准。 网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字。 通信的两端都要有Socket，是两台机器间通信的端点。 网络通信其实就是Socket间的通信。 Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输。 一般主动发起通信的应用程序属客户端，等待通信请求的为服务端。 Socket分类： 流套接字（stream socket）：使用TCP提供可依赖的字节流服务数据报套接字（datagram socket）：使用UDP提供“尽力而为”的数据报服务 Socket类的常用构造器： public Socket(InetAddress address,int port)创建一个流套接字并将其连接到指定 IP 地址的指定端口号。public Socket(String host,int port)创建一个流套接字并将其连接到指定主机上的指定端口号。 Socket类的常用方法： public InputStream getInputStream()返回此套接字的输入流。可以用于接收网络消息public OutputStream getOutputStream()返回此套接字的输出流。可以用于发送网络消息public InetAddress getInetAddress()此套接字连接到的远程 IP 地址；如果套接字是未连接的，则返回 null。public InetAddress getLocalAddress()获取套接字绑定的本地地址。 即本端的IP地址public int getPort()此套接字连接到的远程端口号；如果尚未连接套接字，则返回 0。public int getLocalPort()返回此套接字绑定到的本地端口。 如果尚未绑定套接字，则返回 -1。即本端的端口号。public void close()关闭此套接字。套接字被关闭后，便不可在以后的网络连接中使用（即无法重新连接或重新绑定）。需要创建新的套接字对象。 关闭此套接字也将会关闭该套接字的 InputStream 和 OutputStream。public void shutdownInput()如果在套接字上调用 shutdownInput() 后从套接字输入流读取内容，则流将返回 EOF（文件结束符）。 即不能在从此套接字的输入流中接收任何数据。public void shutdownOutput()禁用此套接字的输出流。对于 TCP 套接字，任何以前写入的数据都将被发送，并且后跟 TCP 的正常连接终止序列。 如果在套接字上调用 shutdownOutput() 后写入套接字输出流，则该流将抛出 IOException。 即不能通过此套接字的输出流发送任何数据。 TCP网络编程(基于socket) 客户端Socket的工作过程包含以下四个基本的步骤： 创建 Socket：根据指定服务端的 IP 地址或端口号构造 Socket 类对象。若服务器端响应，则建立客户端到服务器的通信线路。若连接失败，会出现异常打开连接到 Socket 的输入/出流： 使用 getInputStream()方法获得输入流，使用getOutputStream()方法获得输出流，进行数据传输按照一定的协议对 Socket 进行读/写操作：通过输入流读取服务器放入线路的信息（但不能读取自己放入线路的信息），通过输出流将信息写入线程关闭 Socket：断开客户端到服务器的连接，释放线路 服务器程序的工作过程包含以下四个基本的步骤： 调用 ServerSocket(int port) ：创建一个服务器端套接字，并绑定到指定端口上。用于监听客户端的请求。调用 accept()：监听连接请求，如果客户端请求连接，则接受连接，返回通信套接字对象。调用 该Socket类对象的 getOutputStream() 和 getInputStream ()：获取输出流和输入流，开始网络数据的发送和接收。关闭ServerSocket和Socket对象：客户端访问结束，关闭通信套接字。 /** * 实现TCP的网络编程 * 例子1：客户端发送信息给服务端，服务端将数据显示在控制台上 */ public class TCPTest1 { //客户端 @Test public void client() { Socket socket = null; OutputStream os = null; try { //1.创建Socket对象，指明服务器端的ip和端口号 InetAddress inet = InetAddress.getByName(\"127.0.0.1\"); socket = new Socket(inet,8899); //2.获取一个输出流，用于输出数据 os = socket.getOutputStream(); //3.写出数据的操作 os.write(\"你好，我是客户端mm\".getBytes()); } catch (IOException e) { e.printStackTrace(); } finally { //4.资源的关闭 if(os != null){ try { os.close(); } catch (IOException e) { e.printStackTrace(); } } if(socket != null){ try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } } } //服务端 @Test public void server() { ServerSocket ss = null; Socket socket = null; InputStream is = null; ByteArrayOutputStream baos = null; try { //1.创建服务器端的ServerSocket，指明自己的端口号 ss = new ServerSocket(8899); //2.调用accept()表示接收来自于客户端的socket socket = ss.accept(); //3.获取输入流 is = socket.getInputStream(); //不建议这样写，可能会有乱码 // byte[] buffer = new byte[1024]; // int len; // while((len = is.read(buffer)) != -1){ // String str = new String(buffer,0,len); // System.out.print(str); // } //4.读取输入流中的数据 baos = new ByteArrayOutputStream(); byte[] buffer = new byte[5]; int len; while((len = is.read(buffer)) != -1){ baos.write(buffer,0,len); } System.out.println(baos.toString()); System.out.println(\"收到了来自于：\" + socket.getInetAddress().getHostAddress() + \"的数据\"); } catch (IOException e) { e.printStackTrace(); } finally { if(baos != null){ //5.关闭资源 try { baos.close(); } catch (IOException e) { e.printStackTrace(); } } if(is != null){ try { is.close(); } catch (IOException e) { e.printStackTrace(); } } if(socket != null){ try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } if(ss != null){ try { ss.close(); } catch (IOException e) { e.printStackTrace(); } } } } } UDP网络编程(基于socket) 类 DatagramSocket 和 DatagramPacket 实现了基于 UDP 协议网络程序。 UDP数据报通过数据报套接字 DatagramSocket 发送和接收，系统不保证UDP数据报一定能够安全送到目的地，也不能确定什么时候可以抵达。 DatagramPacket 对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号。 UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接。如同发快递包裹一样。 DatagramSocket常用方法 public DatagramSocket(int port)创建数据报套接字并将其绑定到本地主机上的指定端口。套接字将被绑定到通配符地址，IP 地址由内核来选择。 public DatagramSocket(int port,InetAddress laddr)创建数据报套接字，将其绑定到指定的本地地址。本地端口必须在 0 到 65535 之间（包括两者）。如果 IP 地址为 0.0.0.0，套接字将被绑定到通配符地址，IP 地址由内核选择。 public void close()关闭此数据报套接字。 public void send(DatagramPacket p)从此套接字发送数据报包。DatagramPacket 包含的信息指示：将要发送的数据、其长度、远程主机的 IP 地址和远程主机的端口号。 public void receive(DatagramPacket p)从此套接字接收数据报包。当此方法返回时，DatagramPacket的缓冲区填充了接收的数据。数据报包也包含发送方的 IP 地址和发送方机器上的端口号。 此方法 在接收到数据报前一直阻塞。数据报包对象的 length 字段包含所接收信息的长度。如果信息比包的长度长，该信息将被截短。 public InetAddress getLocalAddress()获取套接字绑定的本地地址。 public int getLocalPort()返回此套接字绑定的本地主机上的端口号。 public InetAddress getInetAddress()返回此套接字连接的地址。如果套接字未连接，则返回 null。 public int getPort()返回此套接字的端口。如果套接字未连接，则返回 -1 DatagramPacket常用方法 public DatagramPacket(byte[] buf,int length)构造 DatagramPacket，用来接收长度为 length 的数据包。 length 参数必须小于等于 buf.length。 public DatagramPacket(byte[] buf,int length,InetAddress address,int port)构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。length参数必须小于等于 buf.length。 public InetAddress getAddress()返回某台机器的 IP 地址，此数据报将要发往该机器或者是从该机器接收到的。 public int getPort()返回某台远程主机的端口号，此数据报将要发往该主机或者是从该主机接收到的。 public byte[] getData()返回数据缓冲区。接收到的或将要发送的数据从缓冲区中的偏移量 offset 处开始，持续 length 长度。 public int getLength()返回将要发送或接收到的数据的长度。 /** * UDPd协议的网络编程 */ public class UDPTest { //发送端 @Test public void sender() throws IOException { DatagramSocket socket = new DatagramSocket(); String str = \"我是UDP方式发送的导弹\"; byte[] data = str.getBytes(); InetAddress inet = InetAddress.getLocalHost(); DatagramPacket packet = new DatagramPacket(data,0,data.length,inet,9090); socket.send(packet); socket.close(); } //接收端 @Test public void receiver() throws IOException { DatagramSocket socket = new DatagramSocket(9090); byte[] buffer = new byte[100]; DatagramPacket packet = new DatagramPacket(buffer,0,buffer.length); socket.receive(packet); System.out.println(new String(packet.getData(),0,packet.getLength())); socket.close(); } } URL类 URL(Uniform Resource Locator)：统一资源定位符，它表示 Internet 上某一资源的地址 ://:/#片段名?参数列表 构造器 public URL (String spec)：通过一个表示URL地址的字符串可以构造一个URL对象。例如：URL url = new URL (\"http://blog.zhaojq.top\"); public URL(URL context, String spec)：通过基 URL 和相对 URL 构造一个 URL 对象。例如：URL downloadUrl = new URL(url, “download.html\") public URL(String protocol, String host, String file); 例如：new URL(\"http\", \"[blog.zhaojq.top](http://blog.zhaojq.top)\", “download. html\"); public URL(String protocol, String host, int port, String file); 例如: URL gamelan = new URL(\"http\", \"blog.zhaojq.top\", 80, “download.html\"); 属性 public String getProtocol() 获取该URL的协议名 public String getHost() 获取该URL的主机名 public String getPort() 获取该URL的端口号 public String getPath() 获取该URL的文件路径 public String getFile() 获取该URL的文件名 public String getQuery() 获取该URL的查询名 public class URLTest { public static void main(String[] args) { try { URL url = new URL(\"http://localhost:8080/examples/beauty.jpg?username=Tom\"); // public String getProtocol( ) 获取该URL的协议名 System.out.println(url.getProtocol()); // public String getHost( ) 获取该URL的主机名 System.out.println(url.getHost()); // public String getPort( ) 获取该URL的端口号 System.out.println(url.getPort()); // public String getPath( ) 获取该URL的文件路径 System.out.println(url.getPath()); // public String getFile( ) 获取该URL的文件名 System.out.println(url.getFile()); // public String getQuery( ) 获取该URL的查询名 System.out.println(url.getQuery()); } catch (MalformedURLException e) { e.printStackTrace(); } } } 针对HTTP协议的URLConnection类 URL的方法 openStream()：能从网络上读取数据 若希望输出数据，例如向服务器端的 CGI （公共网关接口-Common Gateway Interface-的简称，是用户浏览器和服务器端的应用程序进行连接的接口）程序发送一些数据，则必须先与URL建立连接，然后才能对其进行读写，此时需要使用URLConnection 。 URLConnection：表示到URL所引用的远程对象的连接。当与一个URL建立连接时，首先要在一个 URL 对象上通过方法 openConnection() 生成对应的 URLConnection对象。如果连接过程失败，将产生IOException. URL netchinaren = new URL (\"http://blog.zhaojq.top\");URLConnectonn u = netchinaren.openConnection( ); 通过URLConnection对象获取的输入流和输出流，即可以与现有的CGI程序进行交互。 public Object getContent( ) throws IOExceptionpublic int getContentLength( )public String getContentType( )public long getDate( )public long getLastModified( )public InputStream getInputStream( )throws IOExceptionpublic OutputSteram getOutputStream( )throws IOException public class URLTest { public static void main(String[] args) { HttpURLConnection urlConnection = null; InputStream is = null; FileOutputStream fos = null; try { URL url = new URL(\"http://localhost:8080/examples/beauty.jpg\"); urlConnection = (HttpURLConnection) url.openConnection(); urlConnection.connect(); is = urlConnection.getInputStream(); fos = new FileOutputStream(\"beauty5.jpg\"); byte[] buffer = new byte[1024]; int len; while ((len = is.read(buffer)) != -1) { fos.write(buffer, 0, len); } System.out.println(\"下载完成\"); } catch (IOException e) { e.printStackTrace(); } finally { //关闭资源 if (is != null) { try { is.close(); } catch (IOException e) { e.printStackTrace(); } } if (fos != null) { try { fos.close(); } catch (IOException e) { e.printStackTrace(); } } if (urlConnection != null) { urlConnection.disconnect(); } } } } URI、URL和URN的区别 URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。 URL是uniform resource locator，统一资源定位符，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。 URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。 也就是说，URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。 在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符 合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息， 因此它不能是相对的。 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-14 11:10:37 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/java_version/VERSION.html":{"url":"Chapter1/java_version/VERSION.html","title":"Java各版本特性","keywords":"","body":"jdk版本特性jdk版本特性 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-06 15:33:45 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/java_version/java8.html":{"url":"Chapter1/java_version/java8.html","title":"java8","keywords":"","body":"jdk8jdk8 速度更快 HashMap,ConcurrentHashMap特性改变(链表+红黑树等) --详细看HashMap部分 jvm永久区去掉,MetaSpace 元空间,使用物理内存 代码更少（增加了新的语法 Lambda 表达式） 强大的 Stream API 并行 最大化减少空指针异常 Optional 接口中的默认方法和静态方法 新时间日期 重复注解与类型注解 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-07 13:41:48 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/java_version/java8_lambda.html":{"url":"Chapter1/java_version/java8_lambda.html","title":"Lambda","keywords":"","body":"Lambda表达式原来的写法与lambda表达式对比lambda语法java8内置的四大核心函数式接口Lambda表达式 Lambda 是一个匿名函数，我们可以把 Lambda 表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。 原来的写法与lambda表达式对比 1.匿名内部类 //原来的匿名内部类 @Test public void test1(){ Comparator com = new Comparator(){ @Override public int compare(String o1, String o2) { return Integer.compare(o1.length(), o2.length()); } }; TreeSet ts = new TreeSet<>(com); TreeSet ts2 = new TreeSet<>(new Comparator(){ @Override public int compare(String o1, String o2) { return Integer.compare(o1.length(), o2.length()); } }); } //现在的 Lambda 表达式 @Test public void test2(){ Comparator com = (x, y) -> Integer.compare(x.length(), y.length()); TreeSet ts = new TreeSet<>(com); } 2.集合操作 List emps = Arrays.asList( new Employee(101, \"张三\", 18, 9999.99), new Employee(102, \"李四\", 59, 6666.66), new Employee(103, \"王五\", 28, 3333.33), new Employee(104, \"赵六\", 8, 7777.77), new Employee(105, \"田七\", 38, 5555.55) ); //需求：获取公司中年龄小于 35 的员工信息 public List filterEmployeeAge(List emps){ List list = new ArrayList<>(); for (Employee emp : emps) { if(emp.getAge() list = filterEmployeeAge(emps); for (Employee employee : list) { System.out.println(employee); } } //需求：获取公司中工资大于 5000 的员工信息 public List filterEmployeeSalary(List emps){ List list = new ArrayList<>(); for (Employee emp : emps) { if(emp.getSalary() >= 5000){ list.add(emp); } } return list; } //优化方式二：匿名内部类, 需写接口和实现类,具体看java-learning代码 @Test public void test5(){ List list = filterEmployee(emps, new MyPredicate() { @Override public boolean test(Employee t) { return t.getId() list = filterEmployee(emps, (e) -> e.getAge() list2 = filterEmployee(emps, (e) -> e.getSalary() >= 5000); list2.forEach(System.out::println); } //优化方式四：Stream API @Test public void test7(){ emps.stream() .filter((e) -> e.getAge() lambda语法 Java8中引入了一个新的操作符 \"->\" 该操作符称为箭头操作符或 Lambda 操作符箭头操作符将 Lambda 表达式拆分成两部分, 其中: 左侧:ambda 表达式的参数列表 右侧:Lambda 表达式中所需执行的功能， 即 Lambda 体 语法格式 无参数,无返回值 () -> System.out.println(\"Hello Lambda!\") 有1个参数,无返回值,有1个参数时,小括号可不写 (x) -> System.out.println(x)/ x-> System.out.println(x); 有两个以上的参数，有返回值，并且 Lambda 体中有多条语句 Comparator com = (x, y) -> { System.out.println(\"函数式接口\"); return Integer.compare(x, y); }; 若 Lambda 体中只有一条语句， return 和 大括号都可以省略不写 Comparator com = (x, y) -> Integer.compare(x, y) Lambda 表达式的参数列表的数据类型可以省略不写，因为JVM编译器通过上下文推断出，数据类型，即“类型推断” (Integer x, Integer y) -> Integer.compare(x, y) lambda表达式需要“函数式接口”的支持 函数式接口：接口中只有一个抽象方法的接口，称为函数式接口。 可以使用注解 @FunctionalInterface 修饰,可以检查是否是函数式接口 public class TestLambda2 { @Test public void test1(){ int num = 0;//jdk 1.7 前，必须是 final Runnable r = new Runnable() { @Override public void run() { System.out.println(\"Hello World!\" + num); } }; r.run(); System.out.println(\"-------------------------------\"); Runnable r1 = () -> System.out.println(\"Hello Lambda!\"); r1.run(); } @Test public void test2(){ Consumer con = x -> System.out.println(x); con.accept(\"我和我的祖国！\"); } @Test public void test3(){ Comparator com = (x, y) -> { System.out.println(\"测试多行代码\"); return Integer.compare(x, y); }; } @Test public void test4(){ Comparator com = (x, y) -> Integer.compare(x, y); } //类型抢断示例 @Test public void test5(){ String[] strs = {\"aaa\", \"bbb\", \"ccc\"}; List list = new ArrayList<>(); show(new HashMap<>()); } public void show(Map map){ } //需求：对一个数进行运算 @Test public void test6(){ Integer num = operation(100, (x) -> x * x); System.out.println(num); System.out.println(operation(200, (y) -> y + 200)); } public Integer operation(Integer num, Function function){ return function.apply(num); } } java8内置的四大核心函数式接口 1.Consumer : 消费型接口void accept(T t)2.Supplier : 供给型接口T get()3.Function : 函数型接口R apply(T t)4.Predicate : 断言型接口boolean test(T t) public class TestLambda3 { //Predicate 断言型接口： @Test public void test4(){ List list = Arrays.asList(\"Hello\", \"atguigu\", \"Lambda\", \"www\", \"ok\"); List strList = filterStr(list, (s) -> s.length() > 3); for (String str : strList) { System.out.println(str); } } //需求：将满足条件的字符串，放入集合中 public List filterStr(List list, Predicate pre){ List strList = new ArrayList<>(); for (String str : list) { if(pre.test(str)){ strList.add(str); } } return strList; } //Function 函数型接口： @Test public void test3(){ String newStr = strHandler(\"\\t\\t\\t 我爱我的祖国 \", (str) -> str.trim()); System.out.println(newStr); String subStr = strHandler(\"我爱我的祖国\", (str) -> str.substring(2, 5)); System.out.println(subStr); } //需求：用于处理字符串 public String strHandler(String str, Function fun){ return fun.apply(str); } //Supplier 供给型接口 : @Test public void test2(){ List numList = getNumList(10, () -> (int)(Math.random() * 100)); for (Integer num : numList) { System.out.println(num); } } //需求：产生指定个数的整数，并放入集合中 public List getNumList(int num, Supplier sup){ List list = new ArrayList<>(); for (int i = 0; i 消费型接口 : @Test public void test1(){ happy(10000, (m) -> System.out.println(\"买西瓜花了：\" + m + \"元\")); } public void happy(double money, Consumer con){ con.accept(money); } } 5.其他接口 函数式接口 参数类型 返回类型 用途 BiFunction T,U R 对类型为T,U参数应用操作，返回R类型的结果。包含方法为R apply(T t,U u); UnaryOperator(Function子接口) T T 对类型为T的对象进行一元运算，并返回T类型的结果。包含方法为T apply(T t); BinaryOperator(BiFunction子接口) T,T T 对类型为T的对象进行二元运算，并返回T类型的结果。包含方法为T apply(T t1,T t2); BiConsumer T,U void 对类型为T,U参数应用操作。包含方法为void accept(T t,U u); ToIntFunction ToLongFunction ToDoubleFunction T int,long,double 分别计算int、long、double、值的函数 IntFunction LongFunction DoubleFunction int,long,double R 参数分别为int、long、double类型的函数 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-07 10:18:07 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/java_version/java8_方法与构造器引用.html":{"url":"Chapter1/java_version/java8_方法与构造器引用.html","title":"方法与构造器引用","keywords":"","body":"方法与构造器引用方法与构造器引用 1.方法引用: 若 Lambda 体中的功能，已经有方法提供了实现，可以使用方法引用可以将方法引用理解为 Lambda 表达式的另外一种表现形式） 对象的引用 :: 实例方法名类名 :: 静态方法名类名 :: 实例方法名注意： ①方法引用所引用的方法的参数列表与返回值类型，需要与函数式接口中抽象方法的参数列表和返回值类型保持一致！②若Lambda 的参数列表的第一个参数，是实例方法的调用者，第二个参数(或无参)是实例方法的参数时，格式： ClassName::MethodName //类名 :: 实例方法名 @Test public void test5() { BiPredicate bp = (x, y) -> x.equals(y); System.out.println(bp.test(\"abcde\", \"abcde\")); System.out.println(\"-----------------------------------------\"); BiPredicate bp2 = String::equals; System.out.println(bp2.test(\"abc\", \"abc\")); System.out.println(\"-----------------------------------------\"); Function fun = (e) -> e.show(); System.out.println(fun.apply(new Employee())); System.out.println(\"-----------------------------------------\"); Function fun2 = Employee::show; System.out.println(fun2.apply(new Employee())); } //类名 :: 静态方法名 @Test public void test4() { Comparator com = (x, y) -> Integer.compare(x, y); System.out.println(com.compare(1, 2)); System.out.println(\"-------------------------------------\"); Comparator com2 = Integer::compare; System.out.println(com.compare(2, 2)); } @Test public void test3() { BiFunction fun = (x, y) -> Math.max(x, y); System.out.println(fun.apply(1.5, 22.2)); System.out.println(\"--------------------------------------------------\"); BiFunction fun2 = Math::max; System.out.println(fun2.apply(1.2, 1.5)); } //对象的引用 :: 实例方法名 @Test public void test2() { Employee emp = new Employee(101, \"张三\", 18, 9999.99); Supplier sup = () -> emp.getName(); System.out.println(sup.get()); System.out.println(\"----------------------------------\"); Supplier sup2 = emp::getName; System.out.println(sup2.get()); } @Test public void test1() { PrintStream ps = System.out; Consumer con = (str) -> ps.println(str); con.accept(\"Hello World！\"); System.out.println(\"--------------------------------\"); Consumer con2 = ps::println; con2.accept(\"Hello Java8！\"); Consumer con3 = System.out::println; } 2.构造器引用 :构造器的参数列表，需要与函数式接口中参数列表保持一致 类名::new //构造器引用 @Test public void test7() { Function fun = Employee::new; BiFunction fun2 = Employee::new; } @Test public void test6() { Supplier sup = () -> new Employee(); System.out.println(sup.get()); System.out.println(\"------------------------------------\"); Supplier sup2 = Employee::new; System.out.println(sup2.get()); } 3.数组引用 类型[] :: new //数组引用 @Test public void test8() { Function fun = (args) -> new String[args]; String[] strs = fun.apply(10); System.out.println(strs.length); System.out.println(\"--------------------------\"); Function fun2 = Employee[]::new; Employee[] emps = fun2.apply(20); System.out.println(emps.length); } Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-07 10:21:02 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/java_version/java8_Stream.html":{"url":"Chapter1/java_version/java8_Stream.html","title":"Stream","keywords":"","body":"Stream创建stream中间操作终止操作查找与匹配归约收集Stream 流(Stream) 到底是什么呢？是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。“集合讲的是数据，流讲的是计算！” 注意：Stream 自己不会存储元素Stream 不会改变源对象。相反，他们会返回一个持有结果的新StreamStream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行 创建stream @Test public void test1(){ //1. Collection 提供了两个方法 stream() 与 parallelStream() List list = new ArrayList<>(); Stream stream = list.stream(); //获取一个顺序流 Stream parallelStream = list.parallelStream(); //获取一个并行流 //2. 通过 Arrays 中的 stream() 获取一个数组流 Integer[] nums = new Integer[10]; Stream stream1 = Arrays.stream(nums); //3. 通过 Stream 类中静态方法 of() Stream stream2 = Stream.of(1,2,3,4,5,6); //4. 创建无限流 //迭代 Stream stream3 = Stream.iterate(0, (x) -> x + 2).limit(10); stream3.forEach(System.out::println); //生成 Stream stream4 = Stream.generate(Math::random).limit(2); stream4.forEach(System.out::println); } 中间操作 多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值” 方法 描述 filter(Predicate p) 接收Lambda ，从流中排除某些元素 distinct() 筛选，通过流所生成元素的hashCode() 和equals() 去除重复元素 limit(long maxSize) 截断流，使其元素不超过给定数量 skip(long n) 跳过元素，返回一个扔掉了前n 个元素的流。若流中元素不足n 个，则返回一个空流。与limit(n) 互补 map(Functionf) 接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。 mapToDouble(ToDoubleFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream。 mapToInt(ToIntFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的IntStream。 mapToLong(ToLongFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的LongStream。 flatMap(Function f) 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流 sorted() 产生一个新流，其中按自然顺序排序 sorted(Comparatorcomp) 产生一个新流，其中按比较器顺序排序 public class TestStreamaAPI { //1. 创建 Stream @Test public void test1(){ //1. Collection 提供了两个方法 stream() 与 parallelStream() List list = new ArrayList<>(); Stream stream = list.stream(); //获取一个顺序流 Stream parallelStream = list.parallelStream(); //获取一个并行流 //2. 通过 Arrays 中的 stream() 获取一个数组流 Integer[] nums = new Integer[10]; Stream stream1 = Arrays.stream(nums); //3. 通过 Stream 类中静态方法 of() Stream stream2 = Stream.of(1,2,3,4,5,6); //4. 创建无限流 //迭代 Stream stream3 = Stream.iterate(0, (x) -> x + 2).limit(10); stream3.forEach(System.out::println); //生成 Stream stream4 = Stream.generate(Math::random).limit(2); stream4.forEach(System.out::println); } //2. 中间操作 List emps = Arrays.asList( new Employee(102, \"李四\", 59, 6666.66), new Employee(101, \"张三\", 18, 9999.99), new Employee(103, \"王五\", 28, 3333.33), new Employee(104, \"赵六\", 8, 7777.77), new Employee(104, \"赵六\", 8, 7777.77), new Employee(104, \"赵六\", 8, 7777.77), new Employee(105, \"田七\", 38, 5555.55) ); /* 筛选与切片 filter——接收 Lambda ， 从流中排除某些元素。 limit——截断流，使其元素不超过给定数量。 skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补 distinct——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素 */ //内部迭代：迭代操作 Stream API 内部完成 @Test public void test2(){ //所有的中间操作不会做任何的处理 Stream stream = emps.stream() .filter((e) -> { System.out.println(\"测试中间操作\"); return e.getAge() it = emps.iterator(); while(it.hasNext()){ System.out.println(it.next()); } } @Test public void test4(){ emps.stream() .filter((e) -> { System.out.println(\"短路！\"); // && || return e.getSalary() >= 5000; }).limit(3) .forEach(System.out::println); } @Test public void test5(){ emps.parallelStream() .filter((e) -> e.getSalary() >= 5000) .skip(2) .forEach(System.out::println); } @Test public void test6(){ emps.stream() .distinct() .forEach(System.out::println); } /* 映射 map——接收 Lambda ， 将元素转换成其他形式或提取信息。接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。 flatMap——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流 */ @Test public void test1(){ Stream str = emps.stream() .map((e) -> e.getName()); System.out.println(\"-------------------------------------------\"); List strList = Arrays.asList(\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"); Stream stream = strList.stream() .map(String::toUpperCase); stream.forEach(System.out::println); Stream> stream2 = strList.stream() .map(TestStreamAPI1::filterCharacter); stream2.forEach((sm) -> { sm.forEach(System.out::println); }); System.out.println(\"---------------------------------------------\"); Stream stream3 = strList.stream() .flatMap(TestStreamAPI1::filterCharacter); stream3.forEach(System.out::println); } public static Stream filterCharacter(String str){ List list = new ArrayList<>(); for (Character ch : str.toCharArray()) { list.add(ch); } return list.stream(); } /* sorted()——自然排序 sorted(Comparator com)——定制排序 */ @Test public void test2(){ emps.stream() .map(Employee::getName) .sorted() .forEach(System.out::println); System.out.println(\"------------------------------------\"); emps.stream() .sorted((x, y) -> { if(x.getAge() == y.getAge()){ return x.getName().compareTo(y.getName()); }else{ return Integer.compare(x.getAge(), y.getAge()); } }).forEach(System.out::println); } } 终止操作 终止操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是void 查找与匹配 方法 描述 allMatch(Predicate p) 检查是否匹配所有元素 anyMatch(Predicate p) 检查是否至少匹配一个元素 noneMatch(Predicatep) 检查是否没有匹配所有元素 findFirst() 返回第一个元素 findAny() 返回当前流中的任意元素 count() 返回流中元素总数 max(Comparatorc) 返回流中最大值 min(Comparatorc) 返回流中最小值 forEach(Consumerc) 内部迭代(使用Collection 接口需要用户去做迭代，称为外部迭代。相反，Stream API 使用内部迭代——它帮你把迭代做了) public class TestStreamAPI2 { List emps = Arrays.asList( new Employee(102, \"李四\", 59, 6666.66, Employee.Status.BUSY), new Employee(101, \"张三\", 18, 9999.99, Employee.Status.FREE), new Employee(103, \"王五\", 28, 3333.33, Employee.Status.VOCATION), new Employee(104, \"赵六\", 8, 7777.77, Employee.Status.BUSY), new Employee(104, \"赵六\", 8, 7777.77, Employee.Status.FREE), new Employee(104, \"赵七\", 8, 7777.77, Employee.Status.FREE), new Employee(105, \"田七\", 38, 5555.55, Employee.Status.BUSY) ); //3. 终止操作 /* allMatch——检查是否匹配所有元素 anyMatch——检查是否至少匹配一个元素 noneMatch——检查是否没有匹配的元素 findFirst——返回第一个元素 findAny——返回当前流中的任意元素 count——返回流中元素的总个数 max——返回流中最大值 min——返回流中最小值 */ @Test public void test1(){ boolean bl = emps.stream() .allMatch((e) -> e.getStatus().equals(Employee.Status.BUSY)); System.out.println(bl); boolean bl1 = emps.stream() .anyMatch((e) -> e.getStatus().equals(Employee.Status.BUSY)); System.out.println(bl1); boolean bl2 = emps.stream() .noneMatch((e) -> e.getStatus().equals(Employee.Status.BUSY)); System.out.println(bl2); } @Test public void test2(){ Optional op = emps.stream() .sorted((e1, e2) -> Double.compare(e1.getSalary(), e2.getSalary())) .findFirst();//有可能为空即封装到Optional里 System.out.println(op.get()); System.out.println(\"--------------------------------\"); Optional op2 = emps.parallelStream() .filter((e) -> e.getStatus().equals(Employee.Status.FREE)) .findAny(); System.out.println(op2.get()); } @Test public void test3(){ long count = emps.stream() .filter((e) -> e.getStatus().equals(Employee.Status.FREE)) .count(); System.out.println(count); Optional op = emps.stream() .map(Employee::getSalary) .max(Double::compare); System.out.println(op.get()); Optional op2 = emps.stream() .min((e1, e2) -> Double.compare(e1.getSalary(), e2.getSalary())); System.out.println(op2.get()); } //注意：流进行了终止操作后，不能再次使用 @Test public void test4(){ Stream stream = emps.stream() .filter((e) -> e.getStatus().equals(Employee.Status.FREE)); long count = stream.count(); stream.map(Employee::getSalary) .max(Double::compare); } } 归约 方法 描述 reduce(T iden, BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。返回T reduce(BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。返回Optional 备注：map 和reduce 的连接通常称为map-reduce 模式，因Google 用它来进行网络搜索而出名。 /* 归约 reduce(T identity, BinaryOperator) / reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值。 */ @Test public void test1(){ List list = Arrays.asList(1,2,3,4,5,6,7,8,9,10); Integer sum = list.stream() .reduce(0, (x, y) -> x + y); System.out.println(sum); System.out.println(\"----------------------------------------\"); Optional op = emps.stream() .map(Employee::getSalary) .reduce(Double::sum); System.out.println(op.get()); } //需求：搜索名字中 “六” 出现的次数 @Test public void test2(){ Optional sum = emps.stream() .map(Employee::getName) .flatMap(TestStreamAPI1::filterCharacter) .map((ch) -> { if(ch.equals('六')) return 1; else return 0; }).reduce(Integer::sum); System.out.println(sum.get()); } 收集 方法 描述 collect(Collector c) 将流转换为其他形式。接收一个Collector接口的实现，用于给Stream中元素做汇总的方法 Collector 接口中方法的实现决定了如何对流执行收集操作(如收集到List、Set、Map)。但是Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表: 方法 返回类型 作用 toList List 把流中元素收集到List 示例 Listemps=list.stream().collect(Collectors.toList()); toSet Set 把流中元素收集到Set 示例 Setemps=list.stream().collect(Collectors.toSet()); toCollection Collection 把流中元素收集到创建的集合 示例 Collectionemps=list.stream().collect(Collectors.toCollection(ArrayList::new)); counting Long 计算流中元素的个数 示例 longcount=list.stream().collect(Collectors.counting()); summingInt Integer 对流中元素的整数属性求和 示例 inttotal=list.stream().collect(Collectors.summingInt(Employee::getSalary)); averagingInt Double 计算流中元素Integer属性的平均值 示例 doubleavg=list.stream().collect(Collectors.averagingInt(Employee::getSalary)); summarizingInt IntSummaryStatistics 收集流中Integer属性的统计值。如：平均值 示例 IntSummaryStatisticsiss=list.stream().collect(Collectors.summarizingInt(Employee::getSalary)); joining String 连接流中每个字符串 示例 Stringstr=list.stream().map(Employee::getName).collect(Collectors.joining()); maxBy Optional 根据比较器选择最大值 示例 Optionalmax=list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary))); minBy Optional 根据比较器选择最小值 示例 Optionalmin=list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary))); reducing 归约产生的类型 从一个作为累加器的初始值开始，利用BinaryOperator与流中元素逐个结合，从而归约成单个值 示例 inttotal=list.stream().collect(Collectors.reducing(0,Employee::getSalar,Integer::sum)); collectingAndThen 转换函数返回的类型 包裹另一个收集器，对其结果转换函数 示例 inthow=list.stream().collect(Collectors.collectingAndThen(Collectors.toList(),List::size)); groupingBy Map> 根据某属性值对流分组，属性为K，结果为V 示例 Map> map= list.stream().collect(Collectors.groupingBy(Employee::getStatus)); partitioningBy Map> 根据true或false进行分区 示例 Map>vd=list.stream().collect(Collectors.partitioningBy(Employee::getManage)); //collect——将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法 @Test public void test3(){ List list = emps.stream() .map(Employee::getName) .collect(Collectors.toList()); list.forEach(System.out::println); System.out.println(\"----------------------------------\"); Set set = emps.stream() .map(Employee::getName) .collect(Collectors.toSet()); set.forEach(System.out::println); System.out.println(\"----------------------------------\"); HashSet hs = emps.stream() .map(Employee::getName) .collect(Collectors.toCollection(HashSet::new)); hs.forEach(System.out::println); } @Test public void test4(){ Optional max = emps.stream() .map(Employee::getSalary) .collect(Collectors.maxBy(Double::compare)); System.out.println(max.get()); Optional op = emps.stream() .collect(Collectors.minBy((e1, e2) -> Double.compare(e1.getSalary(), e2.getSalary()))); System.out.println(op.get()); Double sum = emps.stream() .collect(Collectors.summingDouble(Employee::getSalary)); System.out.println(sum); Double avg = emps.stream() .collect(Collectors.averagingDouble(Employee::getSalary)); System.out.println(avg); Long count = emps.stream() .collect(Collectors.counting()); System.out.println(count); System.out.println(\"--------------------------------------------\"); DoubleSummaryStatistics dss = emps.stream() .collect(Collectors.summarizingDouble(Employee::getSalary)); System.out.println(dss.getMax()); } //分组 @Test public void test5(){ Map> map = emps.stream() .collect(Collectors.groupingBy(Employee::getStatus)); System.out.println(map); } //多级分组 @Test public void test6(){ Map>> map = emps.stream() .collect(Collectors.groupingBy(Employee::getStatus, Collectors.groupingBy((e) -> { if(e.getAge() >= 60) return \"老年\"; else if(e.getAge() >= 35) return \"中年\"; else return \"成年\"; }))); System.out.println(map); } //分区 @Test public void test7(){ Map> map = emps.stream() .collect(Collectors.partitioningBy((e) -> e.getSalary() >= 5000)); System.out.println(map); } // @Test public void test8(){ String str = emps.stream() .map(Employee::getName) .collect(Collectors.joining(\",\" , \"----\", \"----\")); System.out.println(str); } @Test public void test9(){ Optional sum = emps.stream() .map(Employee::getSalary) .collect(Collectors.reducing(Double::sum)); System.out.println(sum.get()); } Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-07 10:22:58 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/java_version/java8_Stream并行流与串行流.html":{"url":"Chapter1/java_version/java8_Stream并行流与串行流.html","title":"并行流与串行流","keywords":"","body":"并行流与串行流并行流与串行流 并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。Stream API 可以声明性地通过 parallel() 与sequential() 在并行流与顺序流之间进行切换 //求和 @Test public void test3() { long start = System.currentTimeMillis(); Long sum = LongStream.rangeClosed(0L, 10000000000L) .parallel() //切换并行 .sum(); System.out.println(sum); long end = System.currentTimeMillis(); System.out.println(\"耗费的时间为: \" + (end - start)); } Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-07 09:34:59 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/java_version/java8_Optional.html":{"url":"Chapter1/java_version/java8_Optional.html","title":"Optional","keywords":"","body":"OptionalOptional 容器类,用于尽量避免空指针异常 Optional.of(T t) : 创建一个 Optional 实例 Optional.empty() : 创建一个空的 Optional 实例 Optional.ofNullable(T t):若 t 不为 null,创建 Optional 实例,否则创建空实例 isPresent() : 判断是否包含值 orElse(T t) : 如果调用对象包含值，返回该值，否则返回t orElseGet(Supplier s) :如果调用对象包含值，返回该值，否则返回 s 获取的值 map(Function f): 如果有值对其处理，并返回处理后的Optional，否则返回 Optional.empty() flatMap(Function mapper):与 map 类似，要求返回值必须是Optional //测试类1 public class NewMan { private Optional godness = Optional.empty(); private Godness god; public Optional getGod() { return Optional.of(god); } public NewMan() { } public NewMan(Optional godness) { this.godness = godness; } public Optional getGodness() { return godness; } public void setGodness(Optional godness) { this.godness = godness; } @Override public String toString() { return \"NewMan [godness=\" + godness + \"]\"; } } //测试类2 public class NewMan { private Optional godness = Optional.empty(); private Godness god; public Optional getGod() { return Optional.of(god); } public NewMan() { } public NewMan(Optional godness) { this.godness = godness; } public Optional getGodness() { return godness; } public void setGodness(Optional godness) { this.godness = godness; } @Override public String toString() { return \"NewMan [godness=\" + godness + \"]\"; } } //测试3 public class Godness { private String name; public Godness() { } public Godness(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"Godness [name=\" + name + \"]\"; } } //Optional示例 public class TestOptional { @Test public void test4() { Optional op = Optional.of(new Employee(101, \"张三\", 18, 9999.99)); Optional op2 = op.map(Employee::getName); System.out.println(op2.get()); Optional op3 = op.flatMap((e) -> Optional.of(e.getName())); System.out.println(op3.get()); } @Test public void test3() { Optional op = Optional.ofNullable(new Employee()); if (op.isPresent()) {//判断是否有值 System.out.println(op.get()); } Employee emp = op.orElse(new Employee(\"张三\")); System.out.println(emp); Employee emp2 = op.orElseGet(() -> new Employee()); System.out.println(emp2); } @Test public void test2() { Optional op = Optional.ofNullable(new Employee());//of 和 empty的综合 System.out.println(op.get()); Optional op2 = Optional.empty(); System.out.println(op2.get()); } @Test public void test1() { Optional op = Optional.of(new Employee()); Employee emp = op.get(); System.out.println(emp); } @Test public void test5() { Man man = new Man(); String name = getGodnessName(man); System.out.println(name); } //需求：获取一个名字 public String getGodnessName(Man man) { if (man != null) { Godness g = man.getGod(); if (g != null) { return g.getName(); } } return \"赵小二\"; } //运用 Optional 的实体类 @Test public void test6() { Optional godness = Optional.ofNullable(new Godness(\"林志玲\")); Optional op = Optional.ofNullable(new NewMan(godness)); String name = getGodnessName2(op); System.out.println(name); } public String getGodnessName2(Optional man) { return man.orElse(new NewMan()) .getGodness() .orElse(new Godness(\"赵小二\")) .getName(); } } Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-07 13:36:40 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/java_version/java8_接口默认和静态方法.html":{"url":"Chapter1/java_version/java8_接口默认和静态方法.html","title":"接口默认方法和静态方法","keywords":"","body":"接口中默认方法和静态方法默认方法静态方法接口中默认方法和静态方法 默认方法 Java 8中允许接口中包含具有具体实现的方法，该方法称为“默认方法”，默认方法使用 default 关键字修饰接口默认方法的”类优先”原则:若一个接口中定义了一个默认方法，而另外一个父类或接口中又定义了一个同名的方法时 选择父类中的方法。如果一个父类提供了具体的实现，那么接口中具有相同名称和参数的默认方法会被忽略。 接口冲突。如果一个父接口提供一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法（不管方法是否是默认方法），那么必须覆盖该方法来解决冲突 静态方法 Java8中,接口允许添加静态方法 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-07 13:54:13 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/java_version/java8_新时间日期.html":{"url":"Chapter1/java_version/java8_新时间日期.html","title":"新时间日期API","keywords":"","body":"新时间日期API旧SimpleDateFormat的线程安全问题LocalDate、LocalTime、LocalDateTimeInstant 时间戳Duration 和 Period日期的操作解析和格式化时区的处理与传统日期处理的转换新时间日期API 旧SimpleDateFormat的线程安全问题 多个线程同时格式化,会抛异常 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyyMMdd\"); Callable task = new Callable() { @Override public Date call() throws Exception { return sdf.parse(\"20161121\"); } }; ExecutorService pool = Executors.newFixedThreadPool(10); List> results = new ArrayList<>(); for (int i = 0; i future : results) { System.out.println(future.get()); } pool.shutdown(); 解决线程安全问题 Callable task = new Callable() { @Override public Date call() throws Exception { return DateFormatThreadLocal.convert(\"20161121\"); } }; ExecutorService pool = Executors.newFixedThreadPool(10); List> results = new ArrayList<>(); for (int i = 0; i future : results) { System.out.println(future.get()); } pool.shutdown(); //其中DateFormatThreadLocal public class DateFormatThreadLocal { private static final ThreadLocal df = new ThreadLocal() { protected DateFormat initialValue() { return new SimpleDateFormat(\"yyyyMMdd\"); } }; public static final Date convert(String source) throws ParseException { return df.get().parse(source); } } LocalDate则不存在线程安全问题 DateTimeFormatter dtf = DateTimeFormatter.ofPattern(\"yyyyMMdd\"); Callable task = new Callable() { @Override public LocalDate call() throws Exception { LocalDate ld = LocalDate.parse(\"20161121\", dtf); return ld; } }; ExecutorService pool = Executors.newFixedThreadPool(10); List> results = new ArrayList<>(); for (int i = 0; i future : results) { System.out.println(future.get()); } pool.shutdown(); LocalDate、LocalTime、LocalDateTime LocalDate、LocalTime、LocalDateTime 类的实例是不可变的对象，分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的日期或时间，并不包含当前的时间信息。也不包含与时区相关的信息 方法 描述 示例 now() 静态方法，根据当前时间创建对象 LocalDate localDate = LocalDate.now()LocalTime localTime = LocalTime.now()LocalDateTime localDateTime = LocalDateTime.now() of() 静态方法，根据指定日期/时间创建对象 LocalDate localDate = LocalDate.of(2016, 10, 26)LocalTime localTime = LocalTime.of(02, 22, 56)LocalDateTime localDateTime = LocalDateTime.of(2016, 10, 26, 12, 10, 55) plusDaysplusWeeksplusMonthsplusYears 向当前 LocalDate 对象添加几天、几周、几个月、几年 minusDaysminusWeeksminusMonthsminusYears 从当前 LocalDate 对象减去几天、几周、几个月、几年 plusminus 添加或减少一个 Duration 或 Period withDayOfMonthwithDayOfYearwithMonthwithYear 将月份天数、年份天数、月份、年份修改为指定的值并返回新的LocalDate 对象 getDayOfMonth 获得月份天数(1-31) getDayOfYear 获得年份天数(1-366) getDayOfWeek 获得星期几(返回一个 DayOfWeek枚举值) getMonth 获得月份, 返回一个 Month 枚举值 getMonthValue 获得月份(1-12) getYear 获得年份 until 获得两个日期之间的 Period 对象，或者指定 ChronoUnits 的数字 isBeforeisAfter 比较两个 LocalDate isLeapYear 判断是否是闰年 Instant 时间戳 用于“时间戳”的运算。它是以Unix元年(传统的设定为UTC时区1970年1月1日午夜时分)开始所经历的描述进行运算 @Test public void test2() { Instant ins = Instant.now(); //默认使用 UTC 时区 System.out.println(ins); OffsetDateTime odt = ins.atOffset(ZoneOffset.ofHours(8));//指定时区 System.out.println(odt); System.out.println(ins.toEpochMilli());//转成时间戳 Instant ins2 = Instant.ofEpochSecond(5);//设置Instant/秒 System.out.println(ins2); } Duration 和 Period Duration:用于计算两个“时间”间隔 Period:用于计算两个“日期”间隔 @Test public void test3() { Instant ins1 = Instant.now(); System.out.println(\"--------------------\"); try { Thread.sleep(1000); } catch (InterruptedException e) { } Instant ins2 = Instant.now(); Duration between = Duration.between(ins1, ins2); System.out.println(\"所耗费时间为：\" + between); System.out.println(\"所耗费时间为：\" + between.getSeconds()); System.out.println(\"所耗费时间为：\" + between.toMillis()); System.out.println(\"----------------------------------\"); LocalDate ld1 = LocalDate.now(); LocalDate ld2 = LocalDate.of(2011, 1, 1); Period pe = Period.between(ld2, ld1); System.out.println(pe.getYears()); System.out.println(pe.getMonths()); System.out.println(pe.getDays()); Period until = ld2.until(ld1);//同between System.out.println(until.getYears()); } 日期的操作 TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整到“下个周日”等操作。 TemporalAdjusters : 该类通过静态方法提供了大量的常用 TemporalAdjuster 的实现 @Test public void test4() { LocalDateTime ldt = LocalDateTime.now(); System.out.println(ldt); LocalDateTime ldt2 = ldt.withDayOfMonth(10); System.out.println(ldt2); LocalDateTime ldt3 = ldt.with(TemporalAdjusters.next(DayOfWeek.SUNDAY)); System.out.println(ldt3); //自定义：下一个工作日 LocalDateTime ldt5 = ldt.with((l) -> { LocalDateTime ldt4 = (LocalDateTime) l; DayOfWeek dow = ldt4.getDayOfWeek(); if (dow.equals(DayOfWeek.MONDAY)) { return ldt4.plusDays(7); } else if (dow.equals(DayOfWeek.TUESDAY)) { return ldt4.plusDays(6); } else if (dow.equals(DayOfWeek.SUNDAY)) { return ldt4.plusDays(5); } else if (dow.equals(DayOfWeek.THURSDAY)) { return ldt4.plusDays(4); } else if (dow.equals(DayOfWeek.FRIDAY)) { return ldt4.plusDays(3); } else if (dow.equals(DayOfWeek.SATURDAY)) { return ldt4.plusDays(2); } else { return ldt4.plusDays(1); } }); System.out.println(ldt5); } 解析和格式化 java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法： 预定义的标准格式 语言环境相关的格式 自定义的格式 @Test public void test5() { // DateTimeFormatter dtf = DateTimeFormatter.ISO_LOCAL_DATE; DateTimeFormatter dtf = DateTimeFormatter.ofPattern(\"yyyy年MM月dd日 HH:mm:ss E\"); LocalDateTime ldt = LocalDateTime.now(); String strDate = ldt.format(dtf); System.out.println(strDate); LocalDateTime newLdt = ldt.parse(strDate, dtf); System.out.println(newLdt); } 时区的处理 Java8 中加入了对时区的支持，带时区的时间为分别为： ZonedDateZonedTimeZonedDateTime 其中每个时区都对应着 ID，地区ID都为 “{区域}/{城市}”的格式例如 ：Asia/Shanghai 等 ZoneId：该类中包含了所有的时区信息 getAvailableZoneIds() : 可以获取所有时区时区信息 of(id) : 用指定的时区信息获取 ZoneId 对象 @Test public void test7() { LocalDateTime ldt = LocalDateTime.now(ZoneId.of(\"Asia/Shanghai\")); System.out.println(ldt); ZonedDateTime zdt = ZonedDateTime.now(ZoneId.of(\"US/Pacific\")); System.out.println(zdt); } @Test public void test6() { Set set = ZoneId.getAvailableZoneIds(); set.forEach(System.out::println); } 与传统日期处理的转换 类 To 遗留类 From 遗留类 java.time.Instant java.util.Date Date.from(instant) date.toInstant() java.time.Instant java.sql.Timestamp Timestamp.from(instant) timestamp.toInstant() java.time.ZonedDateTime java.util.GregorianCalendar GregorianCalendar.from(zonedDateTime) cal.toZonedDateTime() java.time.LocalDate java.sql.Time Date.valueOf(localDate) date.toLocalDate() java.time.LocalTime java.sql.Time Date.valueOf(localDate) date.toLocalTime() java.time.LocalDateTime java.sql.Timestamp Timestamp.valueOf(localDateTime) timestamp.toLocalDateTime() java.time.ZoneId java.util.TimeZone Timezone.getTimeZone(id) timeZone.toZoneId() java.time.format.DateTimeFormatter java.text.DateFormat formatter.toFormat() 无 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-07 18:14:27 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/java_version/java8_重复注解与类型注解.html":{"url":"Chapter1/java_version/java8_重复注解与类型注解.html","title":"重复注解与类型注解","keywords":"","body":"重复注解与类型注解重复注解与类型注解 /** * 支持重复注解 */ @Repeatable(MyAnnotations.class) @Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE}) @Retention(RetentionPolicy.RUNTIME) public @interface MyAnnotation { String value() default \"\"; } /** * */ @Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE}) @Retention(RetentionPolicy.RUNTIME) public @interface MyAnnotations { MyAnnotation[] value(); } /** * @description: 测试重复注解 */ public class AnnotatonTest { @Test public void test() throws NoSuchMethodException { Class clazz = AnnotatonTest.class; Method show = clazz.getMethod(\"show\"); MyAnnotation[] annotationsByType = show.getAnnotationsByType(MyAnnotation.class); for (MyAnnotation m : annotationsByType) { System.out.println(m.value()); } } @MyAnnotation(\"thank\") @MyAnnotation(\"you\") public void show(){} } Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-07 18:43:07 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/java_version/java9.html":{"url":"Chapter1/java_version/java9.html","title":"java9","keywords":"","body":"jdk9jdk9 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-06 15:35:15 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/java_version/java10.html":{"url":"Chapter1/java_version/java10.html","title":"java10","keywords":"","body":"jdk10jdk10 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-06 15:35:11 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/java_version/java11.html":{"url":"Chapter1/java_version/java11.html","title":"java11","keywords":"","body":"jdk11jdk11 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-06 15:35:07 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/java_version/java12.html":{"url":"Chapter1/java_version/java12.html","title":"java12","keywords":"","body":"jdk12jdk12 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-06 15:35:02 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/java_version/java13.html":{"url":"Chapter1/java_version/java13.html","title":"java13","keywords":"","body":"jdk13jdk13 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-06 15:34:57 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/java_version/java14.html":{"url":"Chapter1/java_version/java14.html","title":"java814","keywords":"","body":"jdk14jdk14 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-06 15:34:51 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/nio/NIO.html":{"url":"Chapter1/nio/NIO.html","title":"NIO","keywords":"","body":"NIO 介绍NIO 与 IO 的主要区别通道与缓冲区NIO 介绍 Java NIO（New IO）是从Java 1.4版本开始引入的一个新的IO API,可以替代标准的Java IO API.NIO与原来的IO有同样的作用和目的,但是使用的方式完全不同,NIO支持面向缓冲区的、基于通道的IO操作.NIO将以更加高效的方式进行文件的读写操作. NIO 与 IO 的主要区别 IO NIO 面向流(Stream Oriented) 面向缓冲区(Buffer Oriented) 阻塞IO(Blocking IO) 非阻塞IO(NonBlocking IO) 无 选择器(Selectors) 通道与缓冲区 Java NIO系统的核心在于：通道(Channel)和缓冲区(Buffer)。通道表示打开到IO 设备(例如：文件、套接字)的连接。若需要使用NIO 系统，需要获取用于连接IO 设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理.即channel负责传输, buffer负责存储 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-03 13:38:02 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/nio/缓冲区.html":{"url":"Chapter1/nio/缓冲区.html","title":"Buffer(缓冲区)","keywords":"","body":"Buffer(缓冲区)BufferBuffer类型数据存取4个核心属性Buffer的常用方法直接与非直接缓冲区Buffer(缓冲区) Buffer 在 Java NIO 中负责数据的存取。缓冲区就是数组。用于存储不同数据类型的数据 Buffer类型 根据数据类型不同（boolean 除外），提供了相应类型的缓冲区 ByteBuffer CharBuffer ShortBuffer IntBuffer LongBuffer FloatBuffer DoubleBuffer 通过allocate()方法获取缓冲区 数据存取 put() get() 4个核心属性 capacity : 容量，表示缓冲区中最大存储数据的容量。一旦声明不能改变。 limit : 界限，表示缓冲区中可以操作数据的大小。（limit 后数据不能进行读写） position : 位置，表示缓冲区中正在操作数据的位置。 mark : 标记，表示记录当前 position 的位置。可以通过 reset() 恢复到 mark 的位置0 public class TestBuffer { @Test public void test1(){ String str = \"abcde\"; //1. 分配一个指定大小的缓冲区 ByteBuffer buf = ByteBuffer.allocate(1024); System.out.println(\"-----------------allocate()----------------\"); System.out.println(buf.position());//0 System.out.println(buf.limit());//1024 System.out.println(buf.capacity());//1024 //2. 利用 put() 存入数据到缓冲区中 buf.put(str.getBytes()); System.out.println(\"-----------------put()----------------\"); System.out.println(buf.position());//5 System.out.println(buf.limit());//1024 System.out.println(buf.capacity());//1024 //3. 切换读取数据模式 buf.flip(); System.out.println(\"-----------------flip()----------------\"); System.out.println(buf.position());//0 System.out.println(buf.limit());//5 System.out.println(buf.capacity());//1024 //4. 利用 get() 读取缓冲区中的数据 byte[] dst = new byte[buf.limit()]; buf.get(dst); System.out.println(new String(dst, 0, dst.length));//abcde System.out.println(\"-----------------get()----------------\"); System.out.println(buf.position());//5 System.out.println(buf.limit());//5 System.out.println(buf.capacity());//1024 //5. rewind() : 可重复读 buf.rewind(); System.out.println(\"-----------------rewind()----------------\"); System.out.println(buf.position());//0 System.out.println(buf.limit());//5 System.out.println(buf.capacity());//1024 //6. clear() : 清空缓冲区. 但是缓冲区中的数据依然存在，但是处于“被遗忘”状态 buf.clear(); System.out.println(\"-----------------clear()----------------\"); System.out.println(buf.position());//0 System.out.println(buf.limit());//1024 System.out.println(buf.capacity());//1024 System.out.println((char)buf.get());//a } @Test public void test2(){ String str = \"abcde\"; ByteBuffer buf = ByteBuffer.allocate(1024); buf.put(str.getBytes()); buf.flip(); byte[] dst = new byte[buf.limit()]; buf.get(dst, 0, 2); System.out.println(new String(dst, 0, 2));//ab System.out.println(buf.position());//2 //mark() : 标记 buf.mark(); buf.get(dst, 2, 2); System.out.println(new String(dst, 2, 2));//cd System.out.println(buf.position());//4 //reset() : 恢复到 mark 的位置 buf.reset(); System.out.println(buf.position());//2 //判断缓冲区中是否还有剩余数据 if(buf.hasRemaining()){ //获取缓冲区中可以操作的数量 System.out.println(buf.remaining());//3 } } } Buffer的常用方法 IO NIO Buffer clear() 清空缓冲区并返回对缓冲区的引用 Buffer flip() 将缓冲区的界限设置为当前位置，并将当前位置重置为0 int capacity() 返回Buffer 的capacity大小 boolean hasRemaining() 判断缓冲区中是否还有元素 int limit() 返回Buffer 的界限(limit) 的位置 Buffer limit(int n) 将设置缓冲区界限为n, 并返回一个具有新limit 的缓冲区对象 Buffer mark() 对缓冲区设置标记 int position() 返回缓冲区的当前位置position Buffer position(int n) 将设置缓冲区的当前位置为n , 并返回修改后的Buffer 对象 int remaining() 返回position 和limit 之间的元素个数 Buffer reset() 将位置position 转到以前设置的mark 所在的位置 Buffer rewind() 将位置设为为0，取消设置的mark 直接与非直接缓冲区 字节缓冲区要么是直接的，要么是非直接的。如果为直接字节缓冲区，则Java 虚拟机会尽最大努力直接在此缓冲区上执行本机I/O 操作。也就是说，在每次调用基础操作系统的一个本机I/O 操作之前（或之后），虚拟机都会尽量避免将缓冲区的内容复制到中间缓冲区中（或从中间缓冲区中复制内容）。 直接字节缓冲区可以通过调用此类的allocateDirect() 工厂方法来创建。此方法返回的缓冲区进行分配和取消分配所需成本通常高于非直接缓冲区。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，它们对应用程序的内存需求量造成的影响可能并不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的本机I/O 操作影响的大型、持久的缓冲区。一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好处时分配它们。 直接字节缓冲区还可以通过FileChannel 的map() 方法将文件区域直接映射到内存中来创建。该方法返回MappedByteBuffer。Java 平台的实现有助于通过JNI 从本机代码创建直接字节缓冲区。如果以上这些缓冲区中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域不会更改该缓冲区的内容，并且将会在访问期间或稍后的某个时间导致抛出不确定的异常。 字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其isDirect()方法来确定。提供此方法是为了能够在性能关键型代码中执行显式缓冲区管理。 非直接缓冲区：通过 allocate() 方法分配缓冲区，将缓冲区建立在 JVM 的内存中 直接缓冲区：通过 allocateDirect() 方法分配直接缓冲区，将缓冲区建立在物理内存中。可以提高效率 //分配直接缓冲区 ByteBuffer buf = ByteBuffer.allocateDirect(1024); System.out.println(buf.isDirect());//true Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-03 13:37:51 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/nio/通道.html":{"url":"Chapter1/nio/通道.html","title":"Channel(通道)","keywords":"","body":"Channel(通道)Channel通道的主要实现类获取通道的方式通道之间的数据传输字符集：CharsetChannel(通道) Channel 用于源节点与目标节点的连接。在 Java NIO 中负责缓冲区中数据的传输。Channel 本身不存储数据，因此需要配合缓冲区进行传输 通道的主要实现类 java.nio.channels.Channel 接口： FileChannel : 用于读取、写入、映射和操作文件的通道 SocketChannel : 通过TCP 读写网络中的数据 ServerSocketChannel : 可以监听新进来的TCP 连接，对每一个新进来的连接都会创建一个SocketChannel DatagramChannel : 通过UDP 读写网络中的数据通道 获取通道的方式 Java 针对支持通道的类提供了 getChannel() 方法 本地 IO： FileInputStream/FileOutputStream RandomAccessFile 网络IO： Socket ServerSocket DatagramSocket 在 JDK 1.7 中的 NIO.2 针对各个通道提供了静态方法 open() 在 JDK 1.7 中的 NIO.2 的 Files 工具类的 newByteChannel() public class TestChannel { //使用直接缓冲区完成文件的复制(内存映射文件) @Test public void test2() throws IOException{//2127-1902-1777 long start = System.currentTimeMillis(); FileChannel inChannel = FileChannel.open(Paths.get(\"d:/1.mkv\"), StandardOpenOption.READ); FileChannel outChannel = FileChannel.open(Paths.get(\"d:/2.mkv\"), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE); //内存映射文件 MappedByteBuffer inMappedBuf = inChannel.map(MapMode.READ_ONLY, 0, inChannel.size()); MappedByteBuffer outMappedBuf = outChannel.map(MapMode.READ_WRITE, 0, inChannel.size()); //直接对缓冲区进行数据的读写操作 byte[] dst = new byte[inMappedBuf.limit()]; inMappedBuf.get(dst); outMappedBuf.put(dst); inChannel.close(); outChannel.close(); long end = System.currentTimeMillis(); System.out.println(\"耗费时间为：\" + (end - start)); } //利用通道完成文件的复制（非直接缓冲区） @Test public void test1(){//10874-10953 long start = System.currentTimeMillis(); FileInputStream fis = null; FileOutputStream fos = null; //①获取通道 FileChannel inChannel = null; FileChannel outChannel = null; try { fis = new FileInputStream(\"d:/1.mkv\"); fos = new FileOutputStream(\"d:/2.mkv\"); inChannel = fis.getChannel(); outChannel = fos.getChannel(); //②分配指定大小的缓冲区 ByteBuffer buf = ByteBuffer.allocate(1024); //③将通道中的数据存入缓冲区中 while(inChannel.read(buf) != -1){ buf.flip(); //切换读取数据的模式 //④将缓冲区中的数据写入通道中 outChannel.write(buf); buf.clear(); //清空缓冲区 } } catch (IOException e) { e.printStackTrace(); } finally { if(outChannel != null){ try { outChannel.close(); } catch (IOException e) { e.printStackTrace(); } } if(inChannel != null){ try { inChannel.close(); } catch (IOException e) { e.printStackTrace(); } } if(fos != null){ try { fos.close(); } catch (IOException e) { e.printStackTrace(); } } if(fis != null){ try { fis.close(); } catch (IOException e) { e.printStackTrace(); } } } long end = System.currentTimeMillis(); System.out.println(\"耗费时间为：\" + (end - start)); } } 通道之间的数据传输 transferFrom() transferTo() ```java public class TestChannel{ //通道之间的数据传输(直接缓冲区) @Test public void test3() throws IOException{ FileChannel inChannel = FileChannel.open(Paths.get(\"d:/1.mkv\"), StandardOpenOption.READ); FileChannel outChannel = FileChannel.open(Paths.get(\"d:/2.mkv\"), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE); // inChannel.transferTo(0, inChannel.size(), outChannel); outChannel.transferFrom(inChannel, 0, inChannel.size()); inChannel.close(); outChannel.close(); } } ## 分散(Scatter)与聚集(Gather) * 分散读取（Scattering Reads）：将通道中的数据分散到多个缓冲区中 * 聚集写入（Gathering Writes）：将多个缓冲区中的数据聚集到通道中 ```java public class TestChannel{ //分散和聚集 @Test public void test4() throws IOException{ RandomAccessFile raf1 = new RandomAccessFile(\"1.txt\", \"rw\"); //1. 获取通道 FileChannel channel1 = raf1.getChannel(); //2. 分配指定大小的缓冲区 ByteBuffer buf1 = ByteBuffer.allocate(100); ByteBuffer buf2 = ByteBuffer.allocate(1024); //3. 分散读取 ByteBuffer[] bufs = {buf1, buf2}; channel1.read(bufs); for (ByteBuffer byteBuffer : bufs) { byteBuffer.flip(); } System.out.println(new String(bufs[0].array(), 0, bufs[0].limit())); System.out.println(\"-----------------\"); System.out.println(new String(bufs[1].array(), 0, bufs[1].limit())); //4. 聚集写入 RandomAccessFile raf2 = new RandomAccessFile(\"2.txt\", \"rw\"); FileChannel channel2 = raf2.getChannel(); channel2.write(bufs); } } 字符集：Charset 编码：字符串 -> 字节数组 解码：字节数组 -> 字符串 public class TestChannel{ //字符集 @Test public void test6() throws IOException{ Charset cs1 = Charset.forName(\"GBK\"); //获取编码器 CharsetEncoder ce = cs1.newEncoder(); //获取解码器 CharsetDecoder cd = cs1.newDecoder(); CharBuffer cBuf = CharBuffer.allocate(1024); cBuf.put(\"天王盖地虎！\"); cBuf.flip(); //编码 ByteBuffer bBuf = ce.encode(cBuf); for (int i = 0; i map = Charset.availableCharsets(); Set> set = map.entrySet(); for (Entry entry : set) { System.out.println(entry.getKey() + \"=\" + entry.getValue()); } } } Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-03 13:37:20 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/nio/网络通信.html":{"url":"Chapter1/nio/网络通信.html","title":"网络通信","keywords":"","body":"网络通信使用 NIO 完成网络通信的三个核心：阻塞式示例非阻塞式选择器(Selector)socketChannel serverSocketChannel非阻塞式示例代码管道(Pip)网络通信 传统的IO 流都是阻塞式的。也就是说，当一个线程调用read() 或write() 时，该线程被阻塞，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务。因此，在完成网络通信进行IO 操作时，由于线程会阻塞，所以服务器端必须为每个客户端都提供一个独立的线程进行处理，当服务器端需要处理大量客户端时，性能急剧下降。 Java NIO 是非阻塞模式的。当线程从某通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。线程通常将非阻塞IO 的空闲时间用于在其他通道上执行IO 操作，所以单独的线程可以管理多个输入和输出通道。因此，NIO 可以让服务器端使用一个或有限几个线程来同时处理连接到服务器端的所有客户端 使用 NIO 完成网络通信的三个核心： 通道（Channel）：负责连接 java.nio.channels.Channel 接口： SelectableChannel SocketChannelServerSocketChannelDatagramChannelPipe.SinkChannelPipe.SourceChannel 缓冲区（Buffer）：负责数据的存取 选择器（Selector）：是 SelectableChannel 的多路复用器。用于监控 SelectableChannel 的 IO 状况 阻塞式示例 详见Githubjava-learning项目 非阻塞式 选择器(Selector) 选择器（Selector）是SelectableChannle 对象的多路复用器，Selector 可以同时监控多个SelectableChannel 的IO 状况，也就是说，利用Selector 可使一个单独的线程管理多个Channel。Selector 是非阻塞IO 的核心 创建Selector ：通过调用Selector.open() 方法创建一个Selector。 向选择器注册通道：SelectableChannel.register(Selector sel, int ops) 当调用register(Selector sel, int ops) 将通道注册选择器时，选择器对通道的监听事件，需要通过第二个参数ops 指定 可以监听的事件类型（可使用SelectionKey 的四个常量表示）： 读: SelectionKey.OP_READ （1）写: SelectionKey.OP_WRITE （4）连接: SelectionKey.OP_CONNECT（8）接收: SelectionKey.OP_ACCEPT （16） 若注册时不止监听一个事件，则可以使用“位或”操作符连接 socketChannel serverSocketChannel非阻塞式示例代码 详见Githubjava-learning项目 管道(Pip) Java NIO 管道是2个线程之间的单向数据连接。 Pipe有一个source通道和一个sink通道。数据会 被写到sink通道，从source通道读取 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-03 13:36:32 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/nio/NIO2.html":{"url":"Chapter1/nio/NIO2.html","title":"NIO.2","keywords":"","body":"Path与PathsFiles类自动资源管理Path与Paths java.nio.file.Path 接口代表一个平台无关的平台路径，描述了目 录结构中文件的位置。 Paths 提供的 get() 方法用来获取 Path 对象： Path get(String first, String … more) : 用于将多个字符串串连成路径。 Path 常用方法： boolean endsWith(String path) : 判断是否以 path 路径结束boolean startsWith(String path) : 判断是否以 path 路径开始boolean isAbsolute() : 判断是否是绝对路径Path getFileName() : 返回与调用 Path 对象关联的文件名Path getName(int idx) : 返回的指定索引位置 idx 的路径名称int getNameCount() : 返回Path 根目录后面元素的数量Path getParent() ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径Path getRoot() ：返回调用 Path 对象的根路径Path resolve(Path p) :将相对路径解析为绝对路径Path toAbsolutePath() : 作为绝对路径返回调用 Path 对象String toString() ： 返回调用 Path 对象的字符串表示形式 Files类 java.nio.file.Files 用于操作文件或目录的工具类 Files常用方法： Path copy(Path src, Path dest, CopyOption … how) : 文件的复制Path createDirectory(Path path, FileAttribute … attr) : 创建一个目录Path createFile(Path path, FileAttribute … arr) : 创建一个文件void delete(Path path) : 删除一个文件Path move(Path src, Path dest, CopyOption…how) : 将 src 移动到 dest 位置long size(Path path) : 返回 path 指定文件的大小 Files常用方法：用于判断 boolean exists(Path path, LinkOption … opts) : 判断文件是否存在boolean isDirectory(Path path, LinkOption … opts) : 判断是否是目录boolean isExecutable(Path path) : 判断是否是可执行文件boolean isHidden(Path path) : 判断是否是隐藏文件boolean isReadable(Path path) : 判断文件是否可读boolean isWritable(Path path) : 判断文件是否可写boolean notExists(Path path, LinkOption … opts) : 判断文件是否不存在public static A readAttributes(Path path,Class type,LinkOption... options) : 获取与 path 指定的文件相关联的属性 Files常用方法：用于操作内容 SeekableByteChannel newByteChannel(Path path, OpenOption…how) : 获取与指定文件的连接，how 指定打开方式DirectoryStream newDirectoryStream(Path path) : 打开 path 指定的目录InputStream newInputStream(Path path, OpenOption…how):获取 InputStream 对象OutputStream newOutputStream(Path path, OpenOption…how) : 获取 OutputStream 对象 自动资源管理 Java 7 增加了一个新特性，该特性提供了另外 一种管理资源的方式，这种方式能自动关闭文 件。这个特性有时被称为自动资源管理 (Automatic Resource Management, ARM)， 该特 性以 try 语句的扩展版为基础。自动资源管理 主要用于，当不再需要文件（或其他资源）时， 可以防止无意中忘记释放它们注意：① try 语句中声明的资源被隐式声明为 final ，资源的作用局限于带资源的 try 语句② 可以在一条 try 语句中管理多个资源，每个资源以“;” 隔开即可。③ 需要关闭的资源，必须实现了 AutoCloseable 接口或其自接口 Closeable Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-03 13:35:45 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/juc/JUC.html":{"url":"Chapter1/juc/JUC.html","title":"JUC","keywords":"","body":"JAVA并发包JUC(java.util.concurrent包)JAVA并发包JUC(java.util.concurrent包) 在 Java 5.0 提供了 java.util.concurrent （简称 JUC ）包，在此包中增加了在并发编程中很常用 的实用工具类，用于定义类似于线程的自定义子 系统，包括线程池、异步 IO 和轻量级任务框架。 提供可调的、灵活的线程池。还提供了设计用于 多线程上下文中的 Collection 实现等 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-03 13:42:51 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/juc/1_volatile.html":{"url":"Chapter1/juc/1_volatile.html","title":"volatile","keywords":"","body":"volatile关键字内存可见性volatilevolatile关键字 内存可见性 内存可见性（Memory Visibility）是指当某个线程正在使用对象状态而另一个线程在同时修改该状态，需要确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。 可见性错误是指当读操作与写操作在不同的线程中执行时，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。 我们可以通过同步来保证对象被安全地发布。除此之外我们也可以使用一种更加轻量级的 volatile 变量 volatile Java 提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他线程。可以将 volatile 看做一个轻量级的锁，但是又与 锁有些不同： 对于多线程，不是一种互斥关系 不能保证变量状态的“原子性操作” /* * 一、volatile 关键字：当多个线程进行操作共享数据时，可以保证内存中的数据可见。 * 相较于 synchronized 是一种较为轻量级的同步策略。 * * 注意： * 1. volatile 不具备“互斥性” * 2. volatile 不能保证变量的“原子性” */ public class TestVolatile { public static void main(String[] args) { ThreadDemo td = new ThreadDemo(); new Thread(td).start(); while(true){ if(td.isFlag()){ //如果不加volatile,则以下 ---- 不会打印 System.out.println(\"------------------\"); break; } } } } class ThreadDemo implements Runnable { private volatile boolean flag = false; @Override public void run() { try { Thread.sleep(200); } catch (InterruptedException e) { } flag = true; System.out.println(\"flag=\" + isFlag()); } public boolean isFlag() { return flag; } public void setFlag(boolean flag) { this.flag = flag; } Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-03 14:04:03 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/juc/2_原子变量与CAS算法.html":{"url":"Chapter1/juc/2_原子变量与CAS算法.html","title":"原子变量与CAS","keywords":"","body":"原子变量CAS算法模拟CAS算法CAS算法的缺点原子变量 类的小工具包，支持在单个变量上解除锁的线程安全编程。事实上，此包中的类可将 volatile 值、字段和数组元素的概念扩展到那些也提供原子条件更新操作的类。 类 AtomicBoolean、AtomicInteger、AtomicLong 和 AtomicReference 的实例各自提供对相应类型单个变量的访问和更新。每个类也为该类型提供适当的实用工具方法。 AtomicIntegerArray、AtomicLongArray 和 AtomicReferenceArray 类进一步扩展了原子操作，对这些类型的数组提供了支持。这些类在为其数组元素提供 volatile 访问语义方面也引人注目，这对于普通数组来说是不受支持的。 核心方法：boolean compareAndSet(expectedValue, updateValue) java.util.concurrent.atomic 包下提供了一些原子操作的常用类: AtomicBoolean 、AtomicInteger 、AtomicLong 、 AtomicReferenceAtomicIntegerArray 、AtomicLongArrayAtomicMarkableReferenceAtomicReferenceArrayAtomicStampedReference CAS算法 CAS (Compare-And-Swap) 是一种硬件对并发的支持，针对多处理器操作而设计的处理器中的一种特殊指令，用于管理对共享数据的并发访问。 CAS 是一种无锁的非阻塞算法的实现。 CAS 包含了 3 个操作数： 需要读写的内存值 V 进行比较的值 A 拟写入的新值 B 当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值，否则不会执行任何操作 public class TestAtomicDemo { public static void main(String[] args) { AtomicDemo ad = new AtomicDemo(); for (int i = 0; i 模拟CAS算法 /* * 模拟 CAS 算法 */ public class TestCompareAndSwap { public static void main(String[] args) { final CompareAndSwap cas = new CompareAndSwap(); for (int i = 0; i CAS算法的缺点 循环时间长开销很大： 我们可以看到getAndAddInt方法执行时，如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。 只能保证一个共享变量的原子操作： 当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。 ABA问题 如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效讲解博客链接 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-03 16:14:14 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/juc/3_ConcurrentHashMap.html":{"url":"Chapter1/juc/3_ConcurrentHashMap.html","title":"ConcurrentHashMap","keywords":"","body":"ConcurrentHashMapConcurrentHashMap Java 5.0 在 java.util.concurrent 包中提供了多种并发容器类来改进同步容器的性能。 ConcurrentHashMap 同步容器类是Java 5 增加的一个线程安全的哈希表。对于多线程的操作，介于 HashMap 与 Hashtable 之间。内部采用“锁分段”机制替代 Hashtable 的独占锁。进而提高性能。 此包还提供了设计用于多线程上下文中的 Collection 实现：ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、CopyOnWriteArrayList 和 CopyOnWriteArraySet。当期望许多线程访问一个给定 collection 时，ConcurrentHashMap 通常优于同步的 HashMap，ConcurrentSkipListMap 通常优于同步的 TreeMap。当期望的读数和遍历远远大于列表的更新数时，CopyOnWriteArrayList 优于同步的 ArrayList。 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-03 17:31:06 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/juc/4_CountDownLatch.html":{"url":"Chapter1/juc/4_CountDownLatch.html","title":"CountDownLatch","keywords":"","body":"CountDownLatch 闭锁CountDownLatch 闭锁 Java 5.0 在 java.util.concurrent 包中提供了多种并发容器类来改进同步容器的性能。 CountDownLatch 一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。 闭锁可以延迟线程的进度直到其到达终止状态，闭锁可以用来确保某些活动直到其他活动都完成才继续执行： 确保某个计算在其需要的所有资源都被初始化之后才继续执行; 确保某个服务在其依赖的所有其他服务都已经启动之后才启动; 等待直到某个操作所有参与者都准备就绪再继续执行 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-03 18:30:58 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/juc/5_Callable.html":{"url":"Chapter1/juc/5_Callable.html","title":"Callable","keywords":"","body":"CallableCallable Java 5.0 在java.util.concurrent 提供了一个新的创建执行线程的方式：Callable 接口 Callable 接口类似于Runnable，两者都是为那些其实例可能被另一个线程执行的类设计的。但是Runnable 不会返回结果，并且无法抛出经过检查的异常。 Callable 需要依赖FutureTask ，FutureTask 也可以用作闭锁 /* * 一、创建执行线程的方式三：实现 Callable 接口。 相较于实现 Runnable 接口的方式，方法可以有返回值，并且可以抛出异常。 * * 二、执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。 FutureTask 是 Future 接口的实现类 */ public class TestCallable { public static void main(String[] args) { ThreadDemo td = new ThreadDemo(); //1.执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。 FutureTask result = new FutureTask<>(td); new Thread(result).start(); //2.接收线程运算后的结果 try { Integer sum = result.get(); //FutureTask 可用于 闭锁 System.out.println(sum); System.out.println(\"------------------------------------\"); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } } } class ThreadDemo implements Callable{ @Override public Integer call() throws Exception { int sum = 0; for (int i = 0; i Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-06 09:37:18 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/juc/6_Lock.html":{"url":"Chapter1/juc/6_Lock.html","title":"Lock","keywords":"","body":"Lock 显式锁Lock 显式锁 在 Java 5.0 之前，协调共享对象的访问时可以使用的机制只有 synchronized 和 volatile 。Java 5.0 后增加了一些新的机制，但并不是一种替代内置锁的方法，而是当内置锁不适用时，作为一种可选择的高级功能。 ReentrantLock 实现了 Lock 接口，并提供了与synchronized 相同的互斥性和内存可见性。但相较于synchronized 提供了更高的处理锁的灵活性 public class TestLock { public static void main(String[] args) { Ticket ticket = new Ticket(); new Thread(ticket, \"1号窗口\").start(); new Thread(ticket, \"2号窗口\").start(); new Thread(ticket, \"3号窗口\").start(); } } class Ticket implements Runnable{ private int tick = 100; private Lock lock = new ReentrantLock(); @Override public void run() { while(true){ lock.lock(); //上锁 try{ if(tick > 0){ try { Thread.sleep(200); } catch (InterruptedException e) { } System.out.println(Thread.currentThread().getName() + \" 完成售票，余票为：\" + --tick); } }finally{ lock.unlock(); //释放锁 } } } } Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-06 10:09:26 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/juc/7_生产者消费者案例-虚假唤醒.html":{"url":"Chapter1/juc/7_生产者消费者案例-虚假唤醒.html","title":"生产者消费者案例","keywords":"","body":"生产者消费者案例-虚假唤醒正常的生产者消费者案例给生产者设置延时多个生产者消费者生产者消费者案例-虚假唤醒 正常的生产者消费者案例 我们测试的即是唤醒机制,如果没有等待和唤醒,则会出现生产了没有线程消费,消费完了,没有线程生产的现象,这种情况这里不进行验证,我们test wait()和notifyAll()的问题 //1 先定义一个售货员角色类 class Saler { private int product = 0;//产品数量 public synchronized void get() { //进货 if (product >= 5) { //5个为货满 System.out.println(\"产品已满\"); try { this.wait(); } catch (InterruptedException e) { } } else { System.out.println(Thread.currentThread().getName() + \" : \" + ++product); this.notifyAll(); } } public synchronized void sale() { //卖货 if (product 给生产者设置延时 run方法里添加200ms的延时,这时生产者会慢于消费者,货满仍然为1(为了明显显示效果) class Pro implements Runnable { private Saler saler; public Pro(Saler saler) { this.saler = saler; } @Override public void run() { for (int i = 0; i = 1) { System.out.println(\"产品已满\"); try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(Thread.currentThread().getName() + \" : \" + ++product); this.notifyAll(); } public synchronized void sale() {//product = 0; 循环次数：0 if (product 多个生产者消费者 能过以上的处理我们成功解决了上述问题但当存在多个生产者消费者是,会出现新的问题,我们继续分析一下 public class Test { public static void main(String[] args) { Saler saler = new Saler(); Pro pro = new Pro(saler); Con cus = new Con(saler); new Thread(pro, \"生产者 A\").start(); new Thread(cus, \"消费者 B\").start(); new Thread(pro, \"生产者 C\").start(); new Thread(cus, \"消费者 D\").start(); } } //结果如下 发现出现了负数 缺货 缺货 生产者 A : 1 消费者 B : 0 缺货 消费者 D : -1 缺货 生产者 C : 0 消费者 D : -1 缺货 消费者 B : -2 缺货 消费者 D : -3 缺货 消费者 B : -4 缺货 消费者 D : -5 缺货 消费者 B : -6 缺货 消费者 D : -7 缺货 消费者 B : -8 缺货 消费者 D : -9 缺货 消费者 B : -10 缺货 消费者 D : -11 缺货 消费者 B : -12 缺货 消费者 D : -13 缺货 消费者 B : -14 缺货 消费者 D : -15 缺货 消费者 B : -16 缺货 消费者 D : -17 消费者 B : -18 生产者 A : -17 生产者 C : -16 生产者 A : -15 生产者 C : -14 生产者 A : -13 生产者 C : -12 生产者 C : -11 生产者 A : -10 生产者 C : -9 生产者 A : -8 生产者 C : -7 生产者 A : -6 生产者 C : -5 生产者 A : -4 生产者 C : -3 生产者 A : -2 生产者 A : -1 生产者 C : 0 //原因分析 假设2个消费者同时抢占资源 //当1个消费者抢占锁后,发现product==0,则wait()并释放锁, 此时另一个消费者抢占资源,发现product==0,也wait()并释放锁 //此时当生产者执行notifyAll()后, 同时唤醒2个消费者,都执行--product操作,即产生负数情况 //这就叫做虚假唤醒 //解决方案,将if替换为while, 被唤醒后重新判断product值(jdk api中有说明) class Saler { private int product = 0; public synchronized void get() {//循环次数：0 while (product >= 1) { System.out.println(\"产品已满\"); try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(Thread.currentThread().getName() + \" : \" + ++product); this.notifyAll(); } public synchronized void sale() {//product = 0; 循环次数：0 while (product Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-06 13:08:48 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/juc/8_Condition.html":{"url":"Chapter1/juc/8_Condition.html","title":"Condition","keywords":"","body":"Condition 线程通信线程按序交替Condition 线程通信 Condition 接口描述了可能会与锁有关联的条件变量。这些变量在用法上与使用 Object.wait 访问的隐式监视器类似，但提供了更强大的功能。需要特别指出的是，单个 Lock 可能与多个 Condition 对象关联。为了避免兼容性问题，Condition 方法的名称与对应的 Object 版本中的不同。 在 Condition 对象中，与 wait、notify 和 notifyAll 方法对应的分别是await、signal 和 signalAll。 Condition 实例实质上被绑定到一个锁上。要为特定 Lock 实例获得Condition 实例，请使用其 newCondition() 方法 //使用区别如下 class Clerk2 { private int product = 0; private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); // 进货 public void get() { lock.lock(); try { while (product >= 1) { // 为了避免虚假唤醒，应该总是使用在循环中。 System.out.println(\"产品已满！\"); try { condition.await(); } catch (InterruptedException e) { } } System.out.println(Thread.currentThread().getName() + \" : \" + ++product); condition.signalAll(); } finally { lock.unlock(); } } // 卖货 public void sale() { lock.lock(); try { while (product 线程按序交替 编写一个程序，开启 3 个线程，这三个线程的 ID 分别为 A、B、C，每个线程将自己的 ID 在屏幕上打印 10 遍，要求输出的结果必须按顺序显示如：ABCABCABC…… 依次递归 public class TestABCAlternate { public static void main(String[] args) { AlternateDemo ad = new AlternateDemo(); new Thread(new Runnable() { @Override public void run() { for (int i = 1; i Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-06 13:24:38 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/juc/9_ReadWriteLock.html":{"url":"Chapter1/juc/9_ReadWriteLock.html","title":"ReadWriteLock","keywords":"","body":"ReadWriteLock 读写锁ReadWriteLock 读写锁 ReadWriteLock 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 writer，读取锁可以由多个 reader 线程同时保持。写入锁是独占的。。 ReadWriteLock 读取操作通常不会改变共享资源，但执行写入操作时，必须独占方式来获取锁。对于读取操作占多数的数据结构。 ReadWriteLock 能提供比独占锁更高的并发性。而对于只读的数据结构，其中包含的不变性可以完全不需要考虑加锁操作 读写/写写 互斥 读读不互斥 public class TestReadWriteLock { public static void main(String[] args) { ReadWriteLockDemo rw = new ReadWriteLockDemo(); new Thread(new Runnable() { @Override public void run() { rw.set((int) (Math.random() * 101)); } }, \"Write\").start(); for (int i = 0; i Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-06 13:37:55 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/juc/10_线程8锁.html":{"url":"Chapter1/juc/10_线程8锁.html","title":"线程8锁","keywords":"","body":"线程8锁线程8锁 一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调其中的一个synchronized方法了，其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized方法 锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法 加个普通方法后发现和同步锁无关 换成两个对象后，不是同一把锁了，情况立刻变化。 都换成静态同步方法后，情况又变化 所有的非静态同步方法用的都是同一把锁——实例对象本身，也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。 所有的静态同步方法用的也是同一把锁——类对象本身，这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象 /* * 题目：判断打印的 \"one\" or \"two\" ？ * * 1. 两个普通同步方法，两个线程，标准打印， 打印? //one two * 2. 新增 Thread.sleep() 给 getOne() ,打印? //one two * 3. 新增普通方法 getThree() , 打印? //three one two * 4. 两个普通同步方法，两个 Number 对象，打印? //two one * 5. 修改 getOne() 为静态同步方法，打印? //two one * 6. 修改两个方法均为静态同步方法，一个 Number 对象? //one two * 7. 一个静态同步方法，一个非静态同步方法，两个 Number 对象? //two one * 8. 两个静态同步方法，两个 Number 对象? //one two * * 线程八锁的关键： * ①非静态方法的锁默认为 this, 静态方法的锁为 对应的 Class 实例 * ②某一个时刻内，只能有一个线程持有锁，无论几个方法。 */ public class TestThread8Monitor { public static void main(String[] args) { Number number = new Number(); Number number2 = new Number(); new Thread(new Runnable() { @Override public void run() { number.getOne(); } }).start(); new Thread(new Runnable() { @Override public void run() { // number.getTwo(); number2.getTwo(); } }).start(); /*new Thread(new Runnable() { @Override public void run() { number.getThree(); } }).start();*/ } } class Number { public static synchronized void getOne() {//Number.class try { Thread.sleep(3000); } catch (InterruptedException e) { } System.out.println(\"one\"); } public synchronized void getTwo() {//this System.out.println(\"two\"); } public void getThree() { System.out.println(\"three\"); } } Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-06 13:43:19 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/juc/11_线程池.html":{"url":"Chapter1/juc/11_线程池.html","title":"线程池","keywords":"","body":"线程池线程调度线程池 第四种获取线程的方法：线程池，一个 ExecutorService，它使用可能的几个池线程之一执行每个提交的任务，通常使用 Executors 工厂方法配置。 线程池可以解决两个不同问题：由于减少了每个任务调用的开销，它们通常可以在执行大量异步任务时提供增强的性能，并且还可以提供绑定和管理资源（包括执行任务集时使用的线程）的方法。每个 ThreadPoolExecutor 还维护着一些基本的统计数据，如完成的任务数。 为了便于跨大量上下文使用，此类提供了很多可调整的参数和扩展钩子 (hook)。但是，强烈建议程序员使用较为方便的 Executors 工厂方法 ： Executors.newCachedThreadPool()（无界线程池，可以进行自动线程回收）Executors.newFixedThreadPool(int)（固定大小线程池）Executors.newSingleThreadExecutor()（单个后台线程） 它们均为大多数使用场景预定义了设置 /* * 一、线程池：提供了一个线程队列，队列中保存着所有等待状态的线程。避免了创建与销毁额外开销，提高了响应的速度。 * * 二、线程池的体系结构： * java.util.concurrent.Executor : 负责线程的使用与调度的根接口 * |--**ExecutorService 子接口: 线程池的主要接口 * |--ThreadPoolExecutor 线程池的实现类 * |--ScheduledExecutorService 子接口：负责线程的调度 * |--ScheduledThreadPoolExecutor ：继承 ThreadPoolExecutor， 实现 ScheduledExecutorService * * 三、工具类 : Executors * ExecutorService newFixedThreadPool() : 创建固定大小的线程池 * ExecutorService newCachedThreadPool() : 缓存线程池，线程池的数量不固定，可以根据需求自动的更改数量。 * ExecutorService newSingleThreadExecutor() : 创建单个线程池。线程池中只有一个线程 * * ScheduledExecutorService newScheduledThreadPool() : 创建固定大小的线程，可以延迟或定时的执行任务。 */ public class TestThreadPool { public static void main(String[] args) throws Exception { //1. 创建线程池 ExecutorService pool = Executors.newFixedThreadPool(5); List> list = new ArrayList<>(); for (int i = 0; i future = pool.submit(new Callable() { @Override public Integer call() throws Exception { int sum = 0; for (int i = 0; i future : list) { System.out.println(future.get()); } /*ThreadPoolDemo tpd = new ThreadPoolDemo(); //2. 为线程池中的线程分配任务 for (int i = 0; i 线程调度 一个 ExecutorService，可安排在给定的延迟后运行或定期执行的命令 public class TestScheduledThreadPool { public static void main(String[] args) throws Exception { ScheduledExecutorService pool = Executors.newScheduledThreadPool(5); for (int i = 0; i result = pool.schedule(new Callable() { @Override public Integer call() throws Exception { int num = new Random().nextInt(100);//生成随机数 System.out.println(Thread.currentThread().getName() + \" : \" + num); return num; } }, 1, TimeUnit.SECONDS); System.out.println(result.get()); } pool.shutdown(); } } Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-06 14:48:08 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/juc/12_ForkJoinPool.html":{"url":"Chapter1/juc/12_ForkJoinPool.html","title":"Fork/Join","keywords":"","body":"ForkJoinPool 分支合并框架 工作窃取Fork/Join与线程池的区别测试代码ForkJoinPool 分支合并框架 工作窃取 Fork/Join Fork/Join 框架：就是在必要的情况下，将一个大任务，进行拆分(fork)成若干个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行 join 汇总 与线程池的区别 采用 “工作窃取”模式（work-stealing）：当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。 相对于一般的线程池实现，fork/join框架的优势体现在对其中包含的任务的处理方式上.在一般的线程池中，如果一个线程正在执行的任务由于某些原因无法继续运行，那么该线程会处于等待状态。而在fork/join框架实现中，如果某个子问题由于等待另外一个子问题的完成而无法继续运行。那么处理该子问题的线程会主动寻找其他尚未运行的子问题来执行.这种方式减少了线程的等待时间，提高了性能 测试代码 public class TestForkJoinPool { public static void main(String[] args) { Instant start = Instant.now(); ForkJoinPool pool = new ForkJoinPool(); ForkJoinTask task = new ForkJoinSumCalculate(0L, 50000000000L); Long sum = pool.invoke(task); System.out.println(sum); Instant end = Instant.now(); System.out.println(\"耗费时间为：\" + Duration.between(start, end).toMillis()); } @Test public void test1() { Instant start = Instant.now(); long sum = 0L; for (long i = 0L; i { /** * */ private static final long serialVersionUID = -259195479995561737L; private long start; private long end; private static final long THURSHOLD = 10000L; //临界值 public ForkJoinSumCalculate(long start, long end) { this.start = start; this.end = end; } @Override protected Long compute() { long length = end - start; if (length Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-06 14:37:18 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter2/":{"url":"Chapter2/","title":"GO技术","keywords":"","body":"GO技术GO技术 go在2007年9月形成构想,并于2009年11月发布,发明人是Robert Griesemer,Rob Pike和Ken Thompson. Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-05-06 10:42:21 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter2/go语言环境配置.html":{"url":"Chapter2/go语言环境配置.html","title":"Go语言环境配置","keywords":"","body":"go语言环境配置go语言环境配置 1.使用brew安装最新稳定版本的go 1.13 brew search go ==> Formulae algol68g gnu-go gobuster google-java-format govendor pango anycable-go go gocr google-sparsehash gowsdl pangomm arangodb go-bindata gocryptfs google-sql-tool gox powerline-go argon2 go-jira godep googler gst-plugins-good protoc-gen-go aws-google-auth go-md2man goenv goolabs gx-go pygobject3 baidupcs-go go-statik gofabric8 goose hugo ✔ ringojs bogofilter go@1.10 goffice gopass jfrog-cli-go spaceinvaders-go cargo-c go@1.11 golang-migrate gor jpegoptim spigot cargo-completion go@1.12 gollum goreleaser katago svgo cargo-instruments go@1.13 golo goreman lego wego certigo go@1.9 gom gosu lgogdownloader wireguard-go brew install go@1.13 Updating Homebrew... ==> Downloading https://homebrew.bintray.com/bottles/go@1.13-1.13.10_1.catalina.bottle.tar.gz ==> Downloading from https://akamai.bintray.com/25/2584dae283ebba63091d06fa1fd15ee9d218b79a60f0c19ba38a7ef8b9e08fdc?__gda__=exp=1588738427~hmac=9ae05b9de1d ######################################################################## 100.0% ==> Pouring go@1.13-1.13.10_1.catalina.bottle.tar.gz ==> Caveats go@1.13 is keg-only, which means it was not symlinked into /usr/local, because this is an alternate version of another formula. If you need to have go@1.13 first in your PATH run: echo 'export PATH=\"/usr/local/opt/go@1.13/bin:$PATH\"' >> ~/.zshrc ==> Summary &#x1F37A; /usr/local/Cellar/go@1.13/1.13.10_1: 9,279 files, 414.5MB ==> `brew cleanup` has not been run in 30 days, running now... Removing: /Users/zhaojianqiang/Library/Caches/Homebrew/gcc--9.2.0_2.catalina.bottle.tar.gz... (84.8MB) Removing: /Users/zhaojianqiang/Library/Caches/Homebrew/gmp--6.1.2_2.catalina.bottle.1.tar.gz... (996.4KB) Removing: /Users/zhaojianqiang/Library/Caches/Homebrew/isl--0.21.catalina.bottle.tar.gz... (1.4MB) Removing: /Users/zhaojianqiang/Library/Caches/Homebrew/libmpc--1.1.0.catalina.bottle.tar.gz... (114.4KB) Removing: /Users/zhaojianqiang/Library/Caches/Homebrew/mpfr--4.0.2.catalina.bottle.tar.gz... (1.1MB) Removing: /Users/zhaojianqiang/Library/Caches/Homebrew/gradle--6.0.1.zip... (134.7MB) Removing: /Users/zhaojianqiang/Library/Logs/Homebrew/gmp... (64B) Removing: /Users/zhaojianqiang/Library/Logs/Homebrew/mpfr... (64B) Removing: /Users/zhaojianqiang/Library/Logs/Homebrew/gcc... (64B) Removing: /Users/zhaojianqiang/Library/Logs/Homebrew/gradle... (102B) Removing: /Users/zhaojianqiang/Library/Logs/Homebrew/isl... (64B) Removing: /Users/zhaojianqiang/Library/Logs/Homebrew/groovy... (64B) Removing: /Users/zhaojianqiang/Library/Logs/Homebrew/libmpc... (64B) Pruned 14 symbolic links and 1 directories from /usr/local 到这一步go即安装完成了 2.配置go go env GO111MODULE=\"\" GOARCH=\"amd64\" GOBIN=\"/Users/zhaojianqiang/Documents/code/go/bin\" GOCACHE=\"/Users/zhaojianqiang/Library/Caches/go-build\" GOENV=\"/Users/zhaojianqiang/Library/Application Support/go/env\" GOEXE=\"\" GOFLAGS=\"\" GOHOSTARCH=\"amd64\" GOHOSTOS=\"darwin\" GONOPROXY=\"\" GONOSUMDB=\"\" GOOS=\"darwin\" GOPATH=\"/Users/zhaojianqiang/Documents/code/go\" GOPRIVATE=\"\" GOPROXY=\"https://proxy.golang.org,direct\" GOROOT=\"/usr/local/opt/go@1.13/libexec\" GOSUMDB=\"sum.golang.org\" GOTMPDIR=\"\" GOTOOLDIR=\"/usr/local/opt/go@1.13/libexec/pkg/tool/darwin_amd64\" GCCGO=\"gccgo\" AR=\"ar\" CC=\"clang\" CXX=\"clang++\" CGO_ENABLED=\"1\" GOMOD=\"\" CGO_CFLAGS=\"-g -O2\" CGO_CPPFLAGS=\"\" CGO_CXXFLAGS=\"-g -O2\" CGO_FFLAGS=\"-g -O2\" CGO_LDFLAGS=\"-g -O2\" PKG_CONFIG=\"pkg-config\" GOGCCFLAGS=\"-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/1v/hmp36dtx5wlbpc2zpkk2w2h80000gp/T/go-build469326368=/tmp/go-build -gno-record-gcc-switches -fno-common\" 将GOROOT, GOPATH配置到.bash_profile中 vim .bash_profile #添加如下 注意GOPATH不要配置到go的安装目录下,可以自定义一个目录 #GOROOT： go安装目录 #GOPATH：go工作目录 #GOBIN：go可执行文件目录 #PATH：将go可执行文件加入PATH中，使GO命令与我们编写的GO应用可以全局调用 export GOROOT=/usr/local/opt/go\\@1.13 export GOPATH=/Users/zhaojianqiang/Documents/code/go export GOBIN=$GOPATH/bin export PATH=$PATH:$GOBIN:$GOROOT/bin #完成后保存并使之生效 source .bash_profile 再次使用go env查看, 即可看到刚才配置的信息到此go就完全安装完成了, 常用工具用GoLand, 开始你的go编程之路吧 3.linux配置 以上是mac os系统配置go, linux的go环境配置相当简单 # step1 下载包 wget https://dl.google.com/go/go1.14.4.linux-amd64.tar.gz # step2 解压 tar -C /usr/local -xzf go1.14.4.linux-amd64.tar.gz # step3 环境变量配置 在/etc/profile文件追加 export PATH=$PATH:/usr/local/go/bin # step4 测试安装 创建一个hello.go文件,包含以下代码 package main import \"fmt\" func main() { fmt.Printf(\"hello, world\\n\") } # 编译 go build hello.go # 运行,成功后输入hello, world ./hello Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-01 13:10:22 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter3/":{"url":"Chapter3/","title":"深入理解JVM","keywords":"","body":"深入理解JVM深入理解JVM Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2019-11-07 23:31:37 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter4/":{"url":"Chapter4/","title":"算法知识","keywords":"","body":"算法知识算法知识 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2019-11-07 23:31:37 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter5/":{"url":"Chapter5/","title":"SPRING系列","keywords":"","body":"SPRING系列SPRING系列 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2019-11-07 23:31:37 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter5/Spring.html":{"url":"Chapter5/Spring.html","title":"Spring","keywords":"","body":"SpringSpring Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2019-11-07 23:31:37 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter5/SpringBoot.html":{"url":"Chapter5/SpringBoot.html","title":"SpringBoot","keywords":"","body":"SpringBootSpringBoot Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2019-11-07 23:31:37 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter5/SpringCloud.html":{"url":"Chapter5/SpringCloud.html","title":"SpringCloud","keywords":"","body":"SpringCloudSpringCloud Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2019-11-07 23:31:37 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter6/":{"url":"Chapter6/","title":"DOCKER","keywords":"","body":"DOCKER简介优点组成DOCKER 简介 Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版） 优点 快速，一致地交付您的应用程序, 适用于ci/cd流程 响应式部署和扩展 在同一硬件上运行更多工作负载 组成 镜像(image):Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统 容器(container):镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等 仓库(repository):仓库可看成一个代码控制中心，用来保存镜像 概念 说明 Docker 镜像(Images) Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。 Docker 容器(Container) 容器是独立运行的一个或一组应用，是镜像运行时的实体。 Docker 客户端(Client) Docker 客户端通过命令行或者其他工具使用 Docker SDK (https://docs.docker.com/develop/sdk/) 与 Docker 的守护进程通信。 Docker 主机(Host) 一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。 Docker Registry Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(https://hub.docker.com) 提供了庞大的镜像集合供使用。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 : 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签 Docker Machine Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-01 16:17:13 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter6/CentOS8安装docker.html":{"url":"Chapter6/CentOS8安装docker.html","title":"Docker的安装","keywords":"","body":"CentOS8安装docker-ce安装安装校验CentOS8安装docker-ce Docker现在分为两个版本，Docker CE和Docker EE 其中Docker CE为开源版，Docker EE为企业版 安装 # step 1: 安装必要的一些系统工具 sudo yum install -y yum-utils device-mapper-persistent-data lvm2 # Step 2: 添加软件源信息 sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # Step 3: 更新并安装Docker-CE sudo yum makecache fast sudo yum -y install docker-ce # Step 3.1(非必要步骤): 安装containerd.io. centos8上因containerd.io版本过低, 在step3会报以下异常 上次元数据过期检查：0:03:35 前，执行于 2020年06月30日 星期二 17时31分14秒。 错误： 问题: package docker-ce-3:19.03.12-3.el7.x86_64 requires containerd.io >= 1.2.2-3, but none of the providers can be installed - cannot install the best candidate for the job - package containerd.io-1.2.10-3.2.el7.x86_64 is filtered out by modular filtering - package containerd.io-1.2.13-3.1.el7.x86_64 is filtered out by modular filtering - package containerd.io-1.2.13-3.2.el7.x86_64 is filtered out by modular filtering - package containerd.io-1.2.2-3.3.el7.x86_64 is filtered out by modular filtering - package containerd.io-1.2.2-3.el7.x86_64 is filtered out by modular filtering - package containerd.io-1.2.4-3.1.el7.x86_64 is filtered out by modular filtering - package containerd.io-1.2.5-3.1.el7.x86_64 is filtered out by modular filtering - package containerd.io-1.2.6-3.3.el7.x86_64 is filtered out by modular filtering (尝试添加 '--skip-broken' 来跳过无法安装的软件包 或 '--nobest' 来不只使用最佳选择的软件包) # 可以看到containerd.io >= 1.2.2-3, 但是centos8上没有高版本的containerd.io,这时需要我们手动去下载,完成以下步骤后再执行step3即可 wget https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/stable/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpm yum install ~/containerd.io-1.2.6-3.3.el7.x86_64.rpm # Step 4: 开启Docker服务 sudo service docker start # 注意： # 官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，您可以通过以下方式开启。同理可以开启各种测试版本等。 # vim /etc/yum.repos.d/docker-ee.repo # 将[docker-ce-test]下方的enabled=0修改为enabled=1 # # 安装指定版本的Docker-CE: # Step 1: 查找Docker-CE的版本: # yum list docker-ce.x86_64 --showduplicates | sort -r # Loading mirror speeds from cached hostfile # Loaded plugins: branch, fastestmirror, langpacks # docker-ce.x86_64 17.03.1.ce-1.el7.centos docker-ce-stable # docker-ce.x86_64 17.03.1.ce-1.el7.centos @docker-ce-stable # docker-ce.x86_64 17.03.0.ce-1.el7.centos docker-ce-stable # Available Packages # Step2: 安装指定版本的Docker-CE: (VERSION例如上面的17.03.0.ce.1-1.el7.centos) # sudo yum -y install docker-ce-[VERSION] 安装校验 docker version Client: Docker Engine - Community Version: 19.03.12 API version: 1.40 Go version: go1.13.10 Git commit: 48a66213fe Built: Mon Jun 22 15:46:54 2020 OS/Arch: linux/amd64 Experimental: false Server: Docker Engine - Community Engine: Version: 19.03.12 API version: 1.40 (minimum version 1.12) Go version: go1.13.10 Git commit: 48a66213fe Built: Mon Jun 22 15:45:28 2020 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.2.6 GitCommit: 894b81a4b802e4eb2a91d1ce216b8817763c29fb runc: Version: 1.0.0-rc8 GitCommit: 425e105d5a03fabd737a126ad93d62a9eeede87f docker-init: Version: 0.18.0 GitCommit: fec3683 Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-03 13:38:39 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter6/镜像加速.html":{"url":"Chapter6/镜像加速.html","title":"镜像加速","keywords":"","body":"镜像加速镜像加速 以阿里云的centos为例,在阿里云的容器镜像服务中找到镜像加速链接以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-01 17:02:24 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter6/HelloWorld.html":{"url":"Chapter6/HelloWorld.html","title":"Hello World","keywords":"","body":"Hello WorldHello World Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-09 18:48:08 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter7/":{"url":"Chapter7/","title":"NETTY","keywords":"","body":"NETTYNETTY Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2019-11-07 23:31:37 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter8/":{"url":"Chapter8/","title":"Kafka","keywords":"","body":"KafkaKafka Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-02-18 17:14:41 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter9/":{"url":"Chapter9/","title":"K8S","keywords":"","body":"KubernetesKubernetes Copyright © zhaojq 2019 all right reserved，powered by Gitbook本书发布时间： 2020-07-10 17:52:21 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"}}